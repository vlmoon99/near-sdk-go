// Code generated by NEAR contract generator. DO NOT EDIT.
// This file includes automatic state management.

package main

import (
	contractBuilder "github.com/vlmoon99/near-sdk-go/contract"
	"github.com/vlmoon99/near-sdk-go/env"
	"strconv"
	"encoding/binary"
)


type Counter struct {
    count int
	owner string
}

// @contract:public
// @contract:view
func (c *Counter) GetCount() int {
	return c.count
}

// @contract:public
// @contract:mutating
func (c *Counter) Increment(amount int) int {
	c.count += amount
	return c.count
}

// @contract:public
// @contract:mutating
func (c *Counter) Decrement(amount int) int {
	c.count -= amount
	return c.count
}

// @contract:public
// @contract:mutating
// @contract:payable min_deposit=0.001
func (c *Counter) Reset() string {
	c.count = 0
	return "Counter reset"
}

// @contract:public
// @contract:view
func (c *Counter) Test1() string {
	return ""
}

// @contract:public
// @contract:mutating
func (c *Counter) Test2(value int) int {
	return 0
}

// @contract:public
// @contract:payable min_deposit=0.0005
// @contract:mutating
func (c *Counter) Test3(msg string) string {
	return ""
}

// @contract:private
func (c *Counter) Test4() {
	// internal logic
}

// @contract:public
// @contract:view
func (c *Counter) Test5(key string) int {
	return 0
}

// @contract:public
// @contract:mutating
func (c *Counter) Test6(a, b int) int {
	return 0
}

// @contract:public
// @contract:payable min_deposit=1
// @contract:mutating
func (c *Counter) Test7() string {
	return ""
}

// @contract:private
func (c *Counter) Test8(flag bool) {
	// internal logic
}

// @contract:public
// @contract:view
func (c *Counter) Test9() bool {
	return false
}

// @contract:public
// @contract:mutating
func (c *Counter) Test10(name string, amount int) string {
	return ""
}

// SerializeCounter converts Counter to []byte (TinyGo/WASM-safe)
func SerializeCounter(c *Counter) []byte {
	buf := make([]byte, 0)

	// Serialize count (int64 -> 8 bytes)
	countBytes := make([]byte, 8)
	binary.LittleEndian.PutUint64(countBytes, uint64(c.count))
	buf = append(buf, countBytes...)

	// Serialize owner string: length (uint32) + bytes
	ownerBytes := []byte(c.owner)
	ownerLen := make([]byte, 4)
	binary.LittleEndian.PutUint32(ownerLen, uint32(len(ownerBytes)))
	buf = append(buf, ownerLen...)
	buf = append(buf, ownerBytes...)

	return buf
}

// DeserializeCounter converts []byte back to Counter (TinyGo/WASM-safe)
func DeserializeCounter(data []byte) *Counter {
	c := &Counter{}

	// Read count (8 bytes)
	c.count = int(binary.LittleEndian.Uint64(data[:8]))

	// Read owner string length (4 bytes) and content
	strLen := binary.LittleEndian.Uint32(data[8:12])
	c.owner = string(data[12 : 12+strLen])

	return c
}

// SetContractStateCounter writes Counter to blockchain storage
func SetContractStateCounter(contract *Counter) {
	data := SerializeCounter(contract)

	env.LogString("Serialized length: " + strconv.Itoa(len(data)))

	_, err := env.StorageWrite([]byte("state"), data)
	if err != nil {
		env.PanicStr("Storage write failed: " + err.Error())
	}
}

// GetContractStateCounter reads Counter from blockchain storage
func GetContractStateCounter() *Counter {
	readBytes, err := env.StorageRead([]byte("state"))
	if err != nil {
		env.PanicStr("Storage read failed: " + err.Error())
	}

	if len(readBytes) == 0 {
		env.PanicStr("No state inside smart contract")
	}

	env.LogString("Read bytes length: " + strconv.Itoa(len(readBytes)))

	counter := DeserializeCounter(readBytes)
	return counter
}


//go:export testSetState
func TestSetState() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {

		contract := Counter{
			count: 0,
			owner: "vlmoon.near",
		}

		SetContractStateCounter(&contract)
		msg := "Sucsessful initialization"
		env.LogString(msg)
		state := GetContractStateCounter()
		env.LogString(state.owner)

		// env.ContractValueReturn([]byte(msg))
		return nil
	})
}

//go:export testGetState
func TestGetState() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {

		owner, err := input.JSON.GetString("owner")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}

		contract := Counter{
			count: 0,
			owner: owner,
		}

		SetContractStateCounter(&contract)

		contractBuilder.ReturnValue("Sucsessful initialization")

		return nil
	})
}


//go:export init
func init() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {

		owner, err := input.JSON.GetString("owner")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}

		contract := Counter{
			count: 0,
			owner: owner,
		}

		SetContractStateCounter(&contract)

		contractBuilder.ReturnValue("Sucsessful initialization")

		return nil
	})
}

// From: modules/counter.go
//go:export get_count
func get_count() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		contract := GetContractStateCounter()

		result := contract.GetCount()

		resultStr := strconv.FormatInt(int64(result), 10) // base 10
		env.LogString(resultStr)
		contractBuilder.ReturnValue([]byte(resultStr))

		return nil
	})
}

// From: modules/counter.go
//go:export increment
func increment() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		amountInt64, err := input.JSON.GetInt("amount")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		amount := int(amountInt64)

		// Call method
		result := contract.Increment(amount)

		// Save state
		SetContractStateCounter(contract)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// From: modules/counter.go
//go:export decrement
func decrement() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		amountInt64, err := input.JSON.GetInt("amount")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		amount := int(amountInt64)

		// Call method
		result := contract.Decrement(amount)

		// Save state
		SetContractStateCounter(contract)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// From: modules/counter.go
//go:export reset
func reset() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		// Validate payment: 0.001 NEAR
		if !validatePayment("0.001") {
			env.PanicStr("Insufficient payment attached")
		}

		// Call method
		result := contract.Reset()

		// Save state
		SetContractStateCounter(contract)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// From: modules/counter1.go
//go:export test1
func test1() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		// Call method
		result := contract.Test1()

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// From: modules/counter1.go
//go:export test2
func test2() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		valueInt64, err := input.JSON.GetInt("value")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		value := int(valueInt64)

		// Call method
		result := contract.Test2(value)

		// Save state
		SetContractStateCounter(contract)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// From: modules/counter1.go
//go:export test3
func test3() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		// Validate payment: 0.0005 NEAR
		if !validatePayment("0.0005") {
			env.PanicStr("Insufficient payment attached")
		}

		msg, err := input.JSON.GetString("msg")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}

		// Call method
		result := contract.Test3(msg)

		// Save state
		SetContractStateCounter(contract)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// From: modules/counter1.go
//go:export test5
func test5() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		key, err := input.JSON.GetString("key")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}

		// Call method
		result := contract.Test5(key)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// From: modules/counter1.go
//go:export test6
func test6() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		aInt64, err := input.JSON.GetInt("a")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		a := int(aInt64)

		bInt64, err := input.JSON.GetInt("b")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		b := int(bInt64)

		// Call method
		result := contract.Test6(a, b)

		// Save state
		SetContractStateCounter(contract)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// From: modules/counter1.go
//go:export test7
func test7() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		// Validate payment: 1 NEAR
		if !validatePayment("1") {
			env.PanicStr("Insufficient payment attached")
		}

		// Call method
		result := contract.Test7()

		// Save state
		SetContractStateCounter(contract)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// From: modules/counter1.go
//go:export test9
func test9() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		// Call method
		result := contract.Test9()

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// From: modules/counter1.go
//go:export test10
func test10() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read contract state
		contract := GetContractStateCounter()

		name, err := input.JSON.GetString("name")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}

		amountInt64, err := input.JSON.GetInt("amount")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		amount := int(amountInt64)

		// Call method
		result := contract.Test10(name, amount)

		// Save state
		SetContractStateCounter(contract)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// validatePayment checks if sufficient NEAR is attached
func validatePayment(minDeposit string) bool {
	// TODO: Implement payment validation
	// attached := env.AttachedDeposit()
	// required := parseNEAR(minDeposit)
	// return attached >= required
	return true
}
