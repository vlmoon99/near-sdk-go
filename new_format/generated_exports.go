// Code generated by NEAR contract generator. DO NOT EDIT.

package main

import (
	contractBuilder "github.com/vlmoon99/near-sdk-go/contract"
	"github.com/vlmoon99/near-sdk-go/env"
	"github.com/vlmoon99/near-sdk-go/borsh"
)

// State struct
type Counter struct {
    Count int
	Owner string
}

// Method from: modules/counter.go
func (c *Counter) GetCount() int {
	return c.Count
}

// Method from: modules/counter.go
func (c *Counter) Increment(amount int) int {
	c.Count += amount
	return c.Count
}

// Method from: modules/counter.go
func (c *Counter) Decrement(amount int) int {
	c.Count -= amount
	return c.Count
}

// Method from: modules/counter.go
func (c *Counter) Reset() string {
	c.Count = 0
	return "Counter reset"
}

// Method from: modules/counter1.go
func (c *Counter) Test1() string {
	return ""
}

// Method from: modules/counter1.go
func (c *Counter) Test2(value int) int {
	return 0
}

// Method from: modules/counter1.go
func (c *Counter) Test3(msg string) string {
	return ""
}

// Method from: modules/counter1.go
func (c *Counter) Test4() {
	// internal logic
}

// Method from: modules/counter1.go
func (c *Counter) Test5(key string) int {
	return 0
}

// Method from: modules/counter1.go
func (c *Counter) Test6(a, b int) int {
	return 0
}

// Method from: modules/counter1.go
func (c *Counter) Test7() string {
	return ""
}

// Method from: modules/counter1.go
func (c *Counter) Test8(flag bool) {
	// internal logic
}

// Method from: modules/counter1.go
func (c *Counter) Test9() bool {
	return false
}

// Method from: modules/counter1.go
func (c *Counter) Test10(name string, amount int) string {
	return ""
}

// getState reads and deserializes Counter from blockchain
func getState() *Counter {
	val, err := env.StateRead()
	if err != nil || len(val) == 0 {
		return &Counter{}
	}

	var state Counter
	err = borsh.Deserialize(val, &state)
	if err != nil {
		env.PanicStr("Failed to deserialize state")
	}

	return &state
}

// setState serializes and writes Counter to blockchain
func setState(state *Counter) {
	val, err := borsh.Serialize(state)
	if err != nil {
		env.PanicStr("Failed to serialize state")
	}

	err = env.StateWrite(val)
	if err != nil {
		env.PanicStr("Failed to write state")
	}
}

// Export: get_count (from modules/counter.go)
//go:export get_count
func get_count() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Call method
		result := state.GetCount()

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: increment (from modules/counter.go)
//go:export increment
func increment() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		amountInt64, err := input.JSON.GetInt("amount")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		amount := int(amountInt64)

		// Call method
		result := state.Increment(amount)

		// Save state
		setState(state)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: decrement (from modules/counter.go)
//go:export decrement
func decrement() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		amountInt64, err := input.JSON.GetInt("amount")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		amount := int(amountInt64)

		// Call method
		result := state.Decrement(amount)

		// Save state
		setState(state)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: reset (from modules/counter.go)
//go:export reset
func reset() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 0.001 NEAR
		if !validatePayment("0.001") {
			env.PanicStr("Insufficient payment")
		}

		// Call method
		result := state.Reset()

		// Save state
		setState(state)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: test1 (from modules/counter1.go)
//go:export test1
func test1() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Call method
		result := state.Test1()

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: test2 (from modules/counter1.go)
//go:export test2
func test2() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		valueInt64, err := input.JSON.GetInt("value")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		value := int(valueInt64)

		// Call method
		result := state.Test2(value)

		// Save state
		setState(state)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: test3 (from modules/counter1.go)
//go:export test3
func test3() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 0.0005 NEAR
		if !validatePayment("0.0005") {
			env.PanicStr("Insufficient payment")
		}

		msg, err := input.JSON.GetString("msg")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}

		// Call method
		result := state.Test3(msg)

		// Save state
		setState(state)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: test5 (from modules/counter1.go)
//go:export test5
func test5() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		key, err := input.JSON.GetString("key")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}

		// Call method
		result := state.Test5(key)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: test6 (from modules/counter1.go)
//go:export test6
func test6() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		aInt64, err := input.JSON.GetInt("a")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		a := int(aInt64)

		bInt64, err := input.JSON.GetInt("b")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		b := int(bInt64)

		// Call method
		result := state.Test6(a, b)

		// Save state
		setState(state)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: test7 (from modules/counter1.go)
//go:export test7
func test7() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 1 NEAR
		if !validatePayment("1") {
			env.PanicStr("Insufficient payment")
		}

		// Call method
		result := state.Test7()

		// Save state
		setState(state)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: test9 (from modules/counter1.go)
//go:export test9
func test9() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Call method
		result := state.Test9()

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// Export: test10 (from modules/counter1.go)
//go:export test10
func test10() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		name, err := input.JSON.GetString("name")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}

		amountInt64, err := input.JSON.GetInt("amount")
		if err != nil {
			env.PanicStr("Failed to parse parameter")
		}
		amount := int(amountInt64)

		// Call method
		result := state.Test10(name, amount)

		// Save state
		setState(state)

		contractBuilder.ReturnValue(result)
		return nil
	})
}

// validatePayment checks if sufficient NEAR is attached
func validatePayment(minDeposit string) bool {
	// TODO: Implement payment validation
	return true
}
