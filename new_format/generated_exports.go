// Code generated by NEAR contract generator. DO NOT EDIT.
// This file uses encoding/json for parameter parsing instead of Borsh.

package main

import (
	"github.com/vlmoon99/near-sdk-go/json"
	contractBuilder "github.com/vlmoon99/near-sdk-go/contract"
	"github.com/vlmoon99/near-sdk-go/env"
	"github.com/vlmoon99/near-sdk-go/borsh"
	"github.com/vlmoon99/near-sdk-go/types"
	encodingJson "encoding/json"
	"strconv"
)

// ===== From: counter2.go =====
func (c *Counter) Test12() string {
	return ""
}

func (c *Counter) Test22(value int) int {
	return 0
}

func (c *Counter) Test32(msg string) string {
	return ""
}

func (c *Counter) Test42() {
	// internal logic
}

func (c *Counter) Test52(key string) int {
	return 0
}

func (c *Counter) Test62(a, b int) int {
	return 0
}

func (c *Counter) Test72() string {
	return ""
}

func (c *Counter) Test82(flag bool) {
	// internal logic
}

func (c *Counter) Test92() bool {
	return false
}

func (c *Counter) Test102(name string, amount int) string {
	return ""
}

// ===== From: func1.go =====
func TestIdea() bool {
	builder := json.NewBuilder()
	expected := `{"age":30}`
	result := string(builder.AddInt("age", 30).Build())
	if result != expected {
		env.LogString("Error")
	}
	return true
}

type MyData struct {
    Name string
    Age  int
}

func (c *Counter) ProcessData(data MyData) string {
    // Works!
	return data.Name
}

// ===== From: main.go =====
type Counter struct {
    Count int
	Owner string
}

// ===== From: modules/counter.go =====
func (c *Counter) GetCount() int {
	return c.Count
}

func (c *Counter) Increment(amount int) int {
	c.Count += amount
	return c.Count
}

func (c *Counter) Decrement(amount int) int {
	c.Count -= amount
	return c.Count
}

func (c *Counter) Reset() string {
	c.Count = 0
	return "Counter reset"
}

// ===== From: modules/counter1.go =====
func (c *Counter) Test1() string {
	return ""
}

func (c *Counter) Test2(value int) int {
	return 0
}

func (c *Counter) Test3(msg string) string {
	return ""
}

func (c *Counter) Test4() {
	// internal logic
}

func (c *Counter) Test5(key string) int {
	return 0
}

func (c *Counter) Test6(a, b int) int {
	return 0
}

func (c *Counter) Test7() string {
	return ""
}

func (c *Counter) Test8(flag bool) {
	// internal logic
}

func (c *Counter) Test9() bool {
	return TestIdea();
}

func (c *Counter) Test10(name string, amount int) string {
	return ""
}

// ===== From: modules/sub_module1/counter4.go =====
func (c *Counter) Test14() string {
	return ""
}

func (c *Counter) Test24(value int) int {
	return 0
}

func (c *Counter) Test34(msg string) string {
	return ""
}

func (c *Counter) Test44() {
	// internal logic
}

func (c *Counter) Test54(key string) int {
	return 0
}

func (c *Counter) Test64(a, b int) int {
	return 0
}

func (c *Counter) Test74() string {
	return ""
}

func (c *Counter) Test84(flag bool) {
	// internal logic
}

func (c *Counter) Test94() bool {
	return false
}

func (c *Counter) Test104(name string, amount int) string {
	return ""
}

// ===== From: modules/sub_module2/counter3.go =====
func (c *Counter) Test13() string {
	return ""
}

func (c *Counter) Test23(value int) int {
	return 0
}

func (c *Counter) Test33(msg string) string {
	return ""
}

func (c *Counter) Test43() {
	// internal logic
}

func (c *Counter) Test53(key string) int {
	return 0
}

func (c *Counter) Test63(a, b int) int {
	return 0
}

func (c *Counter) Test73() string {
	return ""
}

func (c *Counter) Test83(flag bool) {
	// internal logic
}

func (c *Counter) Test93() bool {
	return false
}

func (c *Counter) Test103(name string, amount int) string {
	return ""
}

// getState reads and deserializes Counter from blockchain
func getState() *Counter {
	val, err := env.StateRead()
	if err != nil || len(val) == 0 {
		return &Counter{}
	}

	var state Counter
	// Note: State still uses Borsh for compatibility with blockchain storage
	err = borsh.Deserialize(val, &state)
	if err != nil {
		env.PanicStr("Failed to deserialize state")
	}

	return &state
}

// setState serializes and writes Counter to blockchain
func setState(state *Counter) {
	// Note: State still uses Borsh for compatibility with blockchain storage
	val, err := borsh.Serialize(state)
	if err != nil {
		env.PanicStr("Failed to serialize state")
	}

	err = env.StateWrite(val)
	if err != nil {
		env.PanicStr("Failed to write state")
	}
}

// ===== Generated Exports =====
// Export: test12 (from counter2.go)
//go:export test12
func test12() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// No parameters to parse

		// Call method
		result := state.Test12()

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test22 (from counter2.go)
//go:export test22
func test22() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			value int `json:"value"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test22(params.value)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test32 (from counter2.go)
//go:export test32
func test32() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 0.0005 NEAR
		if !validatePayment("0.0005") {
			env.PanicStr("Insufficient payment")
		}

		// Parse input parameters from JSON
		var params struct {
			msg string `json:"msg"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test32(params.msg)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test52 (from counter2.go)
//go:export test52
func test52() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			key string `json:"key"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test52(params.key)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test62 (from counter2.go)
//go:export test62
func test62() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			a int `json:"a"`
			b int `json:"b"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test62(params.a, params.b)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test72 (from counter2.go)
//go:export test72
func test72() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 1 NEAR
		if !validatePayment("1") {
			env.PanicStr("Insufficient payment")
		}

		// No parameters to parse

		// Call method
		result := state.Test72()

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test92 (from counter2.go)
//go:export test92
func test92() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// No parameters to parse

		// Call method
		result := state.Test92()

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test102 (from counter2.go)
//go:export test102
func test102() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			name string `json:"name"`
			amount int `json:"amount"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test102(params.name, params.amount)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: process_data (from func1.go)
//go:export process_data
func process_data() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params MyData
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error for MyData: " + err.Error())
			env.PanicStr("Failed to parse MyData parameter")
		}

		// Call method
		result := state.ProcessData(params)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: get_count (from modules/counter.go)
//go:export get_count
func get_count() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// No parameters to parse

		// Call method
		result := state.GetCount()

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: increment (from modules/counter.go)
//go:export increment
func increment() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			amount int `json:"amount"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Increment(params.amount)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: decrement (from modules/counter.go)
//go:export decrement
func decrement() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			amount int `json:"amount"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Decrement(params.amount)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: reset (from modules/counter.go)
//go:export reset
func reset() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 0.001 NEAR
		if !validatePayment("0.001") {
			env.PanicStr("Insufficient payment")
		}

		// No parameters to parse

		// Call method
		result := state.Reset()

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test1 (from modules/counter1.go)
//go:export test1
func test1() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// No parameters to parse

		// Call method
		result := state.Test1()

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test2 (from modules/counter1.go)
//go:export test2
func test2() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			value int `json:"value"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test2(params.value)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test3 (from modules/counter1.go)
//go:export test3
func test3() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 0.0005 NEAR
		if !validatePayment("0.0005") {
			env.PanicStr("Insufficient payment")
		}

		// Parse input parameters from JSON
		var params struct {
			msg string `json:"msg"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test3(params.msg)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test5 (from modules/counter1.go)
//go:export test5
func test5() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			key string `json:"key"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test5(params.key)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test6 (from modules/counter1.go)
//go:export test6
func test6() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			a int `json:"a"`
			b int `json:"b"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test6(params.a, params.b)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test7 (from modules/counter1.go)
//go:export test7
func test7() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 1 NEAR
		if !validatePayment("1") {
			env.PanicStr("Insufficient payment")
		}

		// No parameters to parse

		// Call method
		result := state.Test7()

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test9 (from modules/counter1.go)
//go:export test9
func test9() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// No parameters to parse

		// Call method
		result := state.Test9()

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test10 (from modules/counter1.go)
//go:export test10
func test10() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			name string `json:"name"`
			amount int `json:"amount"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test10(params.name, params.amount)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test14 (from modules/sub_module1/counter4.go)
//go:export test14
func test14() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// No parameters to parse

		// Call method
		result := state.Test14()

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test24 (from modules/sub_module1/counter4.go)
//go:export test24
func test24() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			value int `json:"value"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test24(params.value)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test34 (from modules/sub_module1/counter4.go)
//go:export test34
func test34() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 0.0005 NEAR
		if !validatePayment("0.0005") {
			env.PanicStr("Insufficient payment")
		}

		// Parse input parameters from JSON
		var params struct {
			msg string `json:"msg"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test34(params.msg)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test54 (from modules/sub_module1/counter4.go)
//go:export test54
func test54() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			key string `json:"key"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test54(params.key)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test64 (from modules/sub_module1/counter4.go)
//go:export test64
func test64() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			a int `json:"a"`
			b int `json:"b"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test64(params.a, params.b)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test74 (from modules/sub_module1/counter4.go)
//go:export test74
func test74() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 1 NEAR
		if !validatePayment("1") {
			env.PanicStr("Insufficient payment")
		}

		// No parameters to parse

		// Call method
		result := state.Test74()

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test94 (from modules/sub_module1/counter4.go)
//go:export test94
func test94() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// No parameters to parse

		// Call method
		result := state.Test94()

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test104 (from modules/sub_module1/counter4.go)
//go:export test104
func test104() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			name string `json:"name"`
			amount int `json:"amount"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test104(params.name, params.amount)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test13 (from modules/sub_module2/counter3.go)
//go:export test13
func test13() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// No parameters to parse

		// Call method
		result := state.Test13()

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test23 (from modules/sub_module2/counter3.go)
//go:export test23
func test23() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			value int `json:"value"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test23(params.value)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test33 (from modules/sub_module2/counter3.go)
//go:export test33
func test33() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 0.0005 NEAR
		if !validatePayment("0.0005") {
			env.PanicStr("Insufficient payment")
		}

		// Parse input parameters from JSON
		var params struct {
			msg string `json:"msg"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test33(params.msg)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test53 (from modules/sub_module2/counter3.go)
//go:export test53
func test53() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			key string `json:"key"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test53(params.key)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test63 (from modules/sub_module2/counter3.go)
//go:export test63
func test63() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			a int `json:"a"`
			b int `json:"b"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test63(params.a, params.b)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test73 (from modules/sub_module2/counter3.go)
//go:export test73
func test73() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Validate payment: 1 NEAR
		if !validatePayment("1") {
			env.PanicStr("Insufficient payment")
		}

		// No parameters to parse

		// Call method
		result := state.Test73()

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test93 (from modules/sub_module2/counter3.go)
//go:export test93
func test93() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// No parameters to parse

		// Call method
		result := state.Test93()

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: test103 (from modules/sub_module2/counter3.go)
//go:export test103
func test103() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// Read state
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			name string `json:"name"`
			amount int `json:"amount"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		result := state.Test103(params.name, params.amount)

		// Save state
		setState(state)

		// Return result as JSON
		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// ===== Helper Functions =====
// validatePayment checks if sufficient NEAR is attached
func validatePayment(minDeposit string) bool {
	// Parse min deposit amount (in NEAR)
	minAmount, err := strconv.ParseFloat(minDeposit, 64)
	if err != nil {
		env.LogString("Invalid min deposit amount: " + minDeposit)
		return false
	}

	// Convert NEAR to yoctoNEAR (1 NEAR = 1e24 yoctoNEAR)
	minYocto := minAmount * 1e24
	// Convert float to string for Uint128 creation
	minYoctoStr := strconv.FormatFloat(minYocto, 'f', 0, 64)
	
	// Create Uint128 from minimum required yoctoNEAR
	minRequired, err := types.U128FromString(minYoctoStr)
	if err != nil {
		env.LogString("Failed to create Uint128 from min deposit: " + err.Error())
		return false
	}

	// Get attached deposit from environment (returns Uint128)
	attachedDeposit, err := env.GetAttachedDeposit()

	// Compare attached deposit with minimum required
	cmpResult := attachedDeposit.Cmp(minRequired)
	if cmpResult < 0 {
		// Convert attached deposit to string for logging
		attachedStr := attachedDeposit.String()
		minRequiredStr := minRequired.String()
		env.LogString("Insufficient payment: attached " + attachedStr + " yoctoNEAR, required " + minRequiredStr + " yoctoNEAR")
		return false
	}

	return true
}

