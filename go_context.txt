### GO PROJECT CONTEXT
### Root: /home/jhonn/dev/near-sdk-go
### Generated at: Thu Dec 25 16:37:16 UTC 2025

==================================================
FILE: README.md
==================================================

# **Near SDK GO**

[![Telegram](https://img.shields.io/badge/Telegram-join%20chat-blue.svg)](https://t.me/go_near_sdk)  
[![Pkg Go Dev](https://img.shields.io/badge/Pkg%20Go%20Dev-view%20docs-blue.svg)](https://pkg.go.dev/github.com/vlmoon99/near-sdk-go)  

**Near SDK GO** is a library designed for smart contract development on the Near Blockchain. This SDK provides the necessary tools for creating, deploying, and testing smart contracts written in Go for the Near Blockchain.

To simplify development on NEAR using Go, you can use the [NEAR Go CLI](https://github.com/vlmoon99/near-cli-go), which streamlines common tasks such as building, deploying, and interacting with smart contracts.

---

## ðŸš¨ **Important Prerequisites** ðŸš¨  

For an optimal development experience, use **Go** version **1.23.7** and **TinyGo** version **0.36.0**.

For more information about the compatibility between Go and TinyGo, please refer to the following:  
- [Go Compatibility Matrix](https://tinygo.org/docs/reference/go-compat-matrix/)  
- [Go Language Features Support](https://tinygo.org/docs/reference/lang-support/)  

Please note that smart contracts run in an isolated environment without access to sockets, files, or other APIs. Therefore, you must test them separately in the Near Blockchain environment before deploying them to production.

---

## **Quick Start**  

**TODO:**
1. Add steps for CLI and manual methods
2. Add instructions for running tests, deploying, and calling functions
3. Add links on managing keys, account system, etc.

---

## **1. Create Project**

```bash
near-go create -p "test1" -m "test1" -t "smart-contract-empty"
```

---

## **2. Build Code**

```bash
near-go build
```

---

## **3. Test Code**

```bash
# Run tests inside the current Go package
near-go test package

# Run tests for the entire project
near-go test project
```

---

## **4. Create/Import Account**

```bash
# Create a testnet account with 10N for future test transactions
# Change accountid.testnet to your preferred account ID
near-go account create -n "testnet" -a "accountid.testnet"

# To deploy your smart contract on the mainnet, import your mainnet account
# Create a mainnet wallet using [Near Wallets](https://wallet.near.org/) providers (e.g., Meteor Wallet)
# Then import it using your seed phrase or private key
near-go account import
```

---

## **5. Deploy Contract**

```bash
# Deploy the smart contract on the testnet or mainnet

# Deploy to testnet
near-go deploy -id "accountid.testnet" -n "testnet"

# Deploy to mainnet
near-go deploy -id "accountid.near" -n "mainnet"
```

---

## **6. Call Contract**

After successful deployment, you can call your smart contract functions and test them:

```bash
# Call a method with arguments:
near-go call \
  --from fromaccountid.testnet \
  --to toaccountid.testnet \
  --function WriteData \
  --args '{"key": "testKey", "data": "test1"}' \
  --gas '100 Tgas' \
  --deposit '0 NEAR' \
  --network testnet

# Or call a method without arguments:
near-go call \
  --from fromaccountid.testnet \
  --to toaccountid.testnet \
  --function ReadIncommingTxData \
  --network testnet
```

---

## **7. Managing in Production**

Before deploying to production, review the following resources to ensure your understanding of the NEAR ecosystem:

1. [NEAR Accounts](https://docs.near.org/protocol/account-model)
2. [NEAR Access Keys](https://docs.near.org/protocol/access-keys)
3. [NEAR Storage](https://docs.near.org/protocol/storage/storage-staking)
4. [Integration Tests on Rust](https://github.com/near/near-workspaces-rs)
5. [Integration Tests on JS](https://github.com/near/near-workspaces-js)
6. [Build Your Own Indexer on Rust](https://github.com/near/near-lake-framework-rs)
7. [Build Your Own Indexer on JS](https://github.com/near/near-lake-framework-js)
8. [Build Your Web3 Client (Frontend)](https://github.com/near/wallet-selector)
9. [Near API JS](https://github.com/near/near-api-js)

---

## **Documentation**

For detailed documentation, refer to the `doc` folder. It contains all the essential information required for building smart contracts using Go.

If you're a beginner, it's highly recommended to start with the tutorials on the [Official NEAR Docs](https://docs.near.org), which guide you through step-by-step lessons. These lessons cover:

1. [What is NEAR?](https://docs.near.org/protocol/basics)  
2. [NEAR Accounts](https://docs.near.org/protocol/account-model)  
3. [Transactions](https://docs.near.org/protocol/transactions)  
4. [What is a Smart Contract?](https://docs.near.org/smart-contracts/what-is)  
5. [What are Web3 Apps?](https://docs.near.org/web3-apps/what-is)

---

## **Status Message Tutorial**

For a hands-on experience, go through the [Status_Message_Tutorial](doc/Status_Message_Tutorial.md). This tutorial will teach you how the NEAR-Go CLI works under the hood. You will learn how to:

- Build Go files into WASM smart contracts  
- Sign and send transactions  
- Deploy code to the blockchain

This will give you a deeper understanding of the full development and deployment process on NEAR using Go.



==================================================
FILE: collections/collections.go
==================================================

// This package provides collections for data manipulation on the blockchain.
package collections

import (
	"encoding/json"
	"errors"

	"github.com/vlmoon99/near-sdk-go/env"
	"github.com/vlmoon99/near-sdk-go/types"
)

const (
	CollectionErrIndexOutOfBounds    = "index out of bounds"
	CollectionErrVectorEmpty         = "vector is empty"
	CollectionErrMapEmpty            = "map is empty"
	CollectionErrNoKeyLessOrEqual    = "no key less than or equal to given key"
	CollectionErrNoKeyGreaterOrEqual = "no key greater than or equal to given key"
	CollectionErrUnsupportedKeyType  = "unsupported key type"
	CollectionErrKeyNotFound         = "key not found"
	CollectionErrValueNotFound       = "value not found in set"
	CollectionErrInconsistentState   = "inconsistent contract state: value index not found"
)

const (
	KeySeparator  = ":"
	KeysPrefix    = "keys"
	ValuesPrefix  = "values"
	IndicesPrefix = "indices"
)

const (
	LogNoFloorKey   = "TreeMap FloorKey: No floor key found"
	LogNoCeilingKey = "TreeMap CeilingKey: No ceiling key found"
)

type Collection interface {
	GetPrefix() string
}

type BaseCollection struct {
	prefix string
}

func NewBaseCollection(prefix string) BaseCollection {
	return BaseCollection{
		prefix: prefix,
	}
}

func (b BaseCollection) GetPrefix() string {
	return b.prefix
}

func (b BaseCollection) createKey(key interface{}) string {
	switch k := key.(type) {
	case string:
		return b.prefix + KeySeparator + k
	case uint64:
		return b.prefix + KeySeparator + types.Uint64ToString(k)
	case int:
		return b.createKey(uint64(k))
	default:
		env.PanicStr(CollectionErrUnsupportedKeyType)
		return ""
	}
}

type Storage interface {
	Read(key string) ([]byte, error)
	Write(key string, value []byte) (bool, error)
	Delete(key string) (bool, error)
	HasKey(key string) (bool, error)
}

type DefaultStorage struct{}

func (s DefaultStorage) Read(key string) ([]byte, error) {
	return env.StorageRead([]byte(key))
}

func (s DefaultStorage) Write(key string, value []byte) (bool, error) {
	return env.StorageWrite([]byte(key), value)
}

func (s DefaultStorage) Delete(key string) (bool, error) {
	return env.StorageRemove([]byte(key))
}

func (s DefaultStorage) HasKey(key string) (bool, error) {
	return env.StorageHasKey([]byte(key))
}

type Serializer interface {
	Serialize(value interface{}) ([]byte, error)
	Deserialize(data []byte, value interface{}) error
}

type DefaultSerializer struct{}

func (s DefaultSerializer) Serialize(value interface{}) ([]byte, error) {
	return json.Marshal(value)
}

func (s DefaultSerializer) Deserialize(data []byte, value interface{}) error {
	return json.Unmarshal(data, value)
}

type Vector[T any] struct {
	BaseCollection
	storage    Storage
	serializer DefaultSerializer
	length     uint64
}

func NewVector[T any](prefix string) *Vector[T] {
	return &Vector[T]{
		BaseCollection: NewBaseCollection(prefix),
		storage:        DefaultStorage{},
		serializer:     DefaultSerializer{},
		length:         0,
	}
}

func (v *Vector[T]) Length() uint64 {
	return v.length
}

func (v *Vector[T]) Push(value T) error {
	data, err := v.serializer.Serialize(value)
	if err != nil {
		return err
	}

	key := v.createKey(v.length)
	_, err = v.storage.Write(key, data)
	if err != nil {
		return err
	}

	v.length++

	return nil
}

func (v *Vector[T]) Get(index uint64) (T, error) {
	var value T
	if index >= v.length {
		return value, errors.New(CollectionErrIndexOutOfBounds)
	}

	key := v.createKey(index)
	data, err := v.storage.Read(key)
	if err != nil {
		return value, err
	}

	err = v.serializer.Deserialize(data, &value)
	return value, err
}

func (v *Vector[T]) Set(index uint64, value T) error {
	if index >= v.length {
		return errors.New(CollectionErrIndexOutOfBounds)
	}

	data, err := v.serializer.Serialize(value)
	if err != nil {
		return err
	}

	key := v.createKey(index)
	_, err = v.storage.Write(key, data)
	return err
}

func (v *Vector[T]) Pop() (T, error) {
	var value T
	if v.length == 0 {
		return value, errors.New(CollectionErrVectorEmpty)
	}

	v.length--
	key := v.createKey(v.length)
	data, err := v.storage.Read(key)
	if err != nil {
		return value, err
	}

	err = v.serializer.Deserialize(data, &value)
	if err != nil {
		return value, err
	}

	_, err = v.storage.Delete(key)
	return value, err
}

func (v *Vector[T]) Clear() error {
	for i := uint64(0); i < v.length; i++ {
		key := v.createKey(i)
		_, err := v.storage.Delete(key)
		if err != nil {
			return err
		}
	}
	v.length = 0
	return nil
}

func (v *Vector[T]) ToSlice() ([]T, error) {
	result := make([]T, v.length)
	for i := uint64(0); i < v.length; i++ {
		value, err := v.Get(i)
		if err != nil {
			return nil, err
		}
		result[i] = value
	}
	return result, nil
}

type LookupMap[K comparable, V any] struct {
	BaseCollection
	storage    Storage
	serializer DefaultSerializer
}

func NewLookupMap[K comparable, V any](prefix string) *LookupMap[K, V] {
	return &LookupMap[K, V]{
		BaseCollection: NewBaseCollection(prefix),
		storage:        DefaultStorage{},
		serializer:     DefaultSerializer{},
	}
}

func (m *LookupMap[K, V]) Insert(key K, value V) error {
	data, err := m.serializer.Serialize(value)
	if err != nil {
		return err
	}

	storageKey := m.createKey(key)
	_, err = m.storage.Write(storageKey, data)
	return err
}

func (m *LookupMap[K, V]) Get(key K) (V, error) {
	var value V
	storageKey := m.createKey(key)
	data, err := m.storage.Read(storageKey)
	if err != nil {
		return value, err
	}
	err = m.serializer.Deserialize(data, &value)
	return value, err
}

func (m *LookupMap[K, V]) Remove(key K) error {
	storageKey := m.createKey(key)
	_, err := m.storage.Delete(storageKey)
	return err
}

func (m *LookupMap[K, V]) Contains(key K) (bool, error) {
	storageKey := m.createKey(key)
	return m.storage.HasKey(storageKey)
}

type UnorderedMap[K comparable, V any] struct {
	BaseCollection
	storage    Storage
	serializer DefaultSerializer
	keys       Vector[[]byte]
	indices    LookupMap[K, uint64]
}

func NewUnorderedMap[K comparable, V any](prefix string) *UnorderedMap[K, V] {
	return &UnorderedMap[K, V]{
		BaseCollection: NewBaseCollection(prefix),
		storage:        DefaultStorage{},
		serializer:     DefaultSerializer{},
		keys:           *NewVector[[]byte](prefix + KeySeparator + KeysPrefix),
		indices:        *NewLookupMap[K, uint64](prefix + KeySeparator + IndicesPrefix),
	}
}

func (m *UnorderedMap[K, V]) Insert(key K, value V) error {
	storageKey := m.createKey(key)
	exists, err := m.storage.HasKey(storageKey)
	if err != nil {
		return err
	}

	data, err := m.serializer.Serialize(value)
	if err != nil {
		return err
	}
	_, err = m.storage.Write(storageKey, data)
	if err != nil {
		return err
	}

	if !exists {
		index := m.keys.Length()
		keyData, err := m.serializer.Serialize(key)
		if err != nil {
			return err
		}
		err = m.keys.Push(keyData)
		if err != nil {
			return err
		}
		err = m.indices.Insert(key, index)
		if err != nil {
			return err
		}
	}

	return nil
}

func (m *UnorderedMap[K, V]) Remove(key K) error {
	storageKey := m.createKey(key)
	exists, err := m.storage.HasKey(storageKey)
	if err != nil {
		return err
	}
	if !exists {
		return errors.New(CollectionErrKeyNotFound)
	}

	index, err := m.indices.Get(key)
	if err != nil {
		length := m.keys.Length()
		for i := uint64(0); i < length; i++ {
			keyData, err := m.keys.Get(i)
			if err != nil {
				return err
			}
			var storedKey K
			err = m.serializer.Deserialize(keyData, &storedKey)
			if err != nil {
				return err
			}
			if storedKey == key {
				if i < length-1 {
					lastKey, err := m.keys.Get(length - 1)
					if err != nil {
						return err
					}
					err = m.keys.Set(i, lastKey)
					if err != nil {
						return err
					}
					var lastKeyObj K
					err = m.serializer.Deserialize(lastKey, &lastKeyObj)
					if err != nil {
						return err
					}
					err = m.indices.Insert(lastKeyObj, i)
					if err != nil {
						return err
					}
				}
				_, err = m.keys.Pop()
				if err != nil {
					return err
				}
				break
			}
		}
	} else {
		length := m.keys.Length()
		if index < length {
			if index != length-1 {
				lastKey, err := m.keys.Get(length - 1)
				if err != nil {
					return err
				}
				err = m.keys.Set(index, lastKey)
				if err != nil {
					return err
				}
				var lastKeyObj K
				err = m.serializer.Deserialize(lastKey, &lastKeyObj)
				if err != nil {
					return err
				}
				err = m.indices.Insert(lastKeyObj, index)
				if err != nil {
					return err
				}
			}
			_, err = m.keys.Pop()
			if err != nil {
				return err
			}
		}
	}

	_, err = m.storage.Delete(storageKey)
	if err != nil {
		return err
	}
	err = m.indices.Remove(key)
	if err != nil {
		return err
	}

	return nil
}

func (m *UnorderedMap[K, V]) Get(key K) (V, error) {
	var value V
	storageKey := m.createKey(key)
	data, err := m.storage.Read(storageKey)
	if err != nil {
		return value, err
	}
	err = m.serializer.Deserialize(data, &value)
	return value, err
}

func (m *UnorderedMap[K, V]) Contains(key K) (bool, error) {
	storageKey := m.createKey(key)
	return m.storage.HasKey(storageKey)
}

func (m *UnorderedMap[K, V]) Keys() ([]K, error) {
	length := m.keys.Length()
	keys := make([]K, length)

	for i := uint64(0); i < length; i++ {
		keyData, err := m.keys.Get(i)
		if err != nil {
			return nil, err
		}

		err = m.serializer.Deserialize(keyData, &keys[i])
		if err != nil {
			return nil, err
		}
	}

	return keys, nil
}

func (m *UnorderedMap[K, V]) Values() ([]V, error) {
	keys, err := m.Keys()
	if err != nil {
		return nil, err
	}

	values := make([]V, len(keys))
	for i, key := range keys {
		value, err := m.Get(key)
		if err != nil {
			return nil, err
		}
		values[i] = value
	}

	return values, nil
}

type KeyValuePair[K comparable, V any] struct {
	Key   K
	Value V
}

func (m *UnorderedMap[K, V]) Items(startIndex uint64, limit *uint64) ([]KeyValuePair[K, V], error) {
	length := m.keys.Length()
	if startIndex >= length {
		return []KeyValuePair[K, V]{}, nil
	}

	endIndex := length
	if limit != nil {
		if *limit < length-startIndex {
			endIndex = startIndex + *limit
		}
	}

	items := make([]KeyValuePair[K, V], endIndex-startIndex)
	for i := startIndex; i < endIndex; i++ {
		keyData, err := m.keys.Get(i)
		if err != nil {
			return nil, err
		}

		var key K
		err = m.serializer.Deserialize(keyData, &key)
		if err != nil {
			return nil, err
		}

		value, err := m.Get(key)
		if err != nil {
			return nil, err
		}

		items[i-startIndex] = KeyValuePair[K, V]{Key: key, Value: value}
	}

	return items, nil
}

func (m *UnorderedMap[K, V]) Seek(startIndex uint64, limit *uint64) ([]KeyValuePair[K, V], error) {
	return m.Items(startIndex, limit)
}

func (m *UnorderedMap[K, V]) Clear() error {
	keys, err := m.Keys()
	if err != nil {
		return err
	}

	for _, key := range keys {
		err := m.Remove(key)
		if err != nil {
			return err
		}
	}

	return nil
}

type LookupSet[T comparable] struct {
	BaseCollection
	storage    Storage
	serializer DefaultSerializer
	length     uint64
}

func NewLookupSet[T comparable](prefix string) *LookupSet[T] {
	return &LookupSet[T]{
		BaseCollection: NewBaseCollection(prefix),
		storage:        DefaultStorage{},
		serializer:     DefaultSerializer{},
		length:         0,
	}
}

func (s *LookupSet[T]) Length() uint64 {
	return s.length
}

func (s *LookupSet[T]) Contains(value T) (bool, error) {
	storageKey := s.createKey(value)
	return s.storage.HasKey(storageKey)
}

func (s *LookupSet[T]) Insert(value T) error {
	storageKey := s.createKey(value)
	exists, err := s.storage.HasKey(storageKey)
	if err != nil {
		return err
	}

	if !exists {
		data, err := s.serializer.Serialize(true)
		if err != nil {
			return err
		}
		_, err = s.storage.Write(storageKey, data)
		if err != nil {
			return err
		}
		s.length++
	}

	return nil
}

func (s *LookupSet[T]) Remove(value T) error {
	storageKey := s.createKey(value)
	exists, err := s.storage.HasKey(storageKey)
	if err != nil {
		return err
	}

	if !exists {
		return errors.New(CollectionErrValueNotFound)
	}

	_, err = s.storage.Delete(storageKey)
	if err != nil {
		return err
	}

	s.length--
	return nil
}

func (s *LookupSet[T]) Clear() error {
	s.length = 0
	return nil
}

type UnorderedSet[T comparable] struct {
	BaseCollection
	storage    Storage
	serializer DefaultSerializer
	values     Vector[[]byte]
	indices    LookupMap[T, uint64]
	length     uint64
}

func NewUnorderedSet[T comparable](prefix string) *UnorderedSet[T] {
	return &UnorderedSet[T]{
		BaseCollection: NewBaseCollection(prefix),
		storage:        DefaultStorage{},
		serializer:     DefaultSerializer{},
		values:         *NewVector[[]byte](prefix + KeySeparator + ValuesPrefix),
		indices:        *NewLookupMap[T, uint64](prefix + KeySeparator + IndicesPrefix),
		length:         0,
	}
}

func (s *UnorderedSet[T]) Length() uint64 {
	return s.length
}

func (s *UnorderedSet[T]) Insert(value T) error {
	storageKey := s.createKey(value)
	exists, err := s.storage.HasKey(storageKey)
	if err != nil {
		return err
	}

	if !exists {
		data, err := s.serializer.Serialize(true)
		if err != nil {
			return err
		}
		_, err = s.storage.Write(storageKey, data)
		if err != nil {
			return err
		}

		index := s.values.Length()
		valueData, err := s.serializer.Serialize(value)
		if err != nil {
			return err
		}
		err = s.values.Push(valueData)
		if err != nil {
			return err
		}

		err = s.indices.Insert(value, index)
		if err != nil {
			return err
		}

		s.length++
	}

	return nil
}

func (s *UnorderedSet[T]) Remove(value T) error {
	storageKey := s.createKey(value)
	exists, err := s.storage.HasKey(storageKey)
	if err != nil {
		return err
	}

	if !exists {
		return errors.New(CollectionErrValueNotFound)
	}

	index, err := s.indices.Get(value)
	if err != nil {
		return errors.New(CollectionErrInconsistentState)
	}

	length := s.values.Length()
	if index < length {
		if index != length-1 {
			lastValue, err := s.values.Get(length - 1)
			if err != nil {
				return err
			}
			err = s.values.Set(index, lastValue)
			if err != nil {
				return err
			}
			var lastValueObj T
			err = s.serializer.Deserialize(lastValue, &lastValueObj)
			if err != nil {
				return err
			}
			err = s.indices.Insert(lastValueObj, index)
			if err != nil {
				return err
			}
		}
		_, err = s.values.Pop()
		if err != nil {
			return err
		}
	}

	err = s.indices.Remove(value)
	if err != nil {
		return err
	}
	_, err = s.storage.Delete(storageKey)
	if err != nil {
		return err
	}

	s.length--
	return nil
}

func (s *UnorderedSet[T]) Contains(value T) (bool, error) {
	storageKey := s.createKey(value)
	return s.storage.HasKey(storageKey)
}

func (s *UnorderedSet[T]) Values(startIndex uint64, limit *uint64) ([]T, error) {
	length := s.values.Length()
	if startIndex >= length {
		return []T{}, nil
	}

	endIndex := length
	if limit != nil {
		if *limit < length-startIndex {
			endIndex = startIndex + *limit
		}
	}

	values := make([]T, endIndex-startIndex)
	for i := startIndex; i < endIndex; i++ {
		valueData, err := s.values.Get(i)
		if err != nil {
			return nil, err
		}

		err = s.serializer.Deserialize(valueData, &values[i-startIndex])
		if err != nil {
			return nil, err
		}
	}

	return values, nil
}

func (s *UnorderedSet[T]) Seek(startIndex uint64, limit *uint64) ([]T, error) {
	return s.Values(startIndex, limit)
}

func (s *UnorderedSet[T]) Clear() error {
	values, err := s.Values(0, nil)
	if err != nil {
		return err
	}

	for _, value := range values {
		storageKey := s.createKey(value)
		_, err = s.storage.Delete(storageKey)
		if err != nil {
			return err
		}

		err = s.indices.Remove(value)
		if err != nil {
			return err
		}
	}

	err = s.values.Clear()
	if err != nil {
		return err
	}

	s.length = 0
	return nil
}

type TreeMap[K comparable, V any] struct {
	BaseCollection
	storage    Storage
	serializer DefaultSerializer
	keys       Vector[[]byte]
}

func NewTreeMap[K comparable, V any](prefix string) *TreeMap[K, V] {
	return &TreeMap[K, V]{
		BaseCollection: NewBaseCollection(prefix),
		storage:        DefaultStorage{},
		serializer:     DefaultSerializer{},
		keys:           *NewVector[[]byte](prefix + KeySeparator + KeysPrefix),
	}
}

func (m *TreeMap[K, V]) findKeyIndex(key K) (int, bool, error) {
	length := m.keys.Length()
	left, right := 0, int(length)-1
	for left <= right {
		mid := (left + right) / 2
		keyData, err := m.keys.Get(uint64(mid))
		if err != nil {
			return 0, false, err
		}
		var midKey K
		err = m.serializer.Deserialize(keyData, &midKey)
		if err != nil {
			return 0, false, err
		}
		cmp := compareKeys(midKey, key)
		if cmp == 0 {
			return mid, true, nil
		} else if cmp < 0 {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return left, false, nil
}

func (m *TreeMap[K, V]) insertAtIndex(index int, key K) error {
	length := m.keys.Length()
	keyData, err := m.serializer.Serialize(key)
	if err != nil {
		return err
	}
	err = m.keys.Push(keyData)
	if err != nil {
		return err
	}
	for i := length; i > uint64(index); i-- {
		prev, err := m.keys.Get(i - 1)
		if err != nil {
			return err
		}
		err = m.keys.Set(i, prev)
		if err != nil {
			return err
		}
	}
	return m.keys.Set(uint64(index), keyData)
}

func (m *TreeMap[K, V]) removeAtIndex(index int) error {
	length := m.keys.Length()
	for i := uint64(index); i < length-1; i++ {
		next, err := m.keys.Get(i + 1)
		if err != nil {
			return err
		}
		err = m.keys.Set(i, next)
		if err != nil {
			return err
		}
	}
	_, err := m.keys.Pop()
	return err
}

func (m *TreeMap[K, V]) Set(key K, value V) error {
	return m.Insert(key, value)
}

func (m *TreeMap[K, V]) Insert(key K, value V) error {
	data, err := m.serializer.Serialize(value)
	if err != nil {
		return err
	}
	storageKey := m.createKey(key)
	_, err = m.storage.Write(storageKey, data)
	if err != nil {
		return err
	}
	index, exists, err := m.findKeyIndex(key)
	if err != nil {
		return err
	}
	if !exists {
		return m.insertAtIndex(index, key)
	}
	return nil
}

func (m *TreeMap[K, V]) Get(key K) (V, error) {
	var value V
	storageKey := m.createKey(key)
	data, err := m.storage.Read(storageKey)
	if err != nil {
		return value, err
	}
	err = m.serializer.Deserialize(data, &value)
	return value, err
}

func (m *TreeMap[K, V]) Remove(key K) error {
	storageKey := m.createKey(key)
	_, err := m.storage.Delete(storageKey)
	if err != nil {
		return err
	}
	index, exists, err := m.findKeyIndex(key)
	if err != nil {
		return err
	}
	if exists {
		return m.removeAtIndex(index)
	}
	return nil
}

func (m *TreeMap[K, V]) Contains(key K) (bool, error) {
	storageKey := m.createKey(key)
	return m.storage.HasKey(storageKey)
}

func (m *TreeMap[K, V]) Keys() ([]K, error) {
	length := m.keys.Length()
	keys := make([]K, length)
	for i := uint64(0); i < length; i++ {
		keyData, err := m.keys.Get(i)
		if err != nil {
			return nil, err
		}
		err = m.serializer.Deserialize(keyData, &keys[i])
		if err != nil {
			return nil, err
		}
	}
	return keys, nil
}

func (m *TreeMap[K, V]) Values() ([]V, error) {
	keys, err := m.Keys()
	if err != nil {
		return nil, err
	}
	values := make([]V, len(keys))
	for i, key := range keys {
		value, err := m.Get(key)
		if err != nil {
			return nil, err
		}
		values[i] = value
	}
	return values, nil
}

func (m *TreeMap[K, V]) Items() ([]struct {
	Key   K
	Value V
}, error) {
	keys, err := m.Keys()
	if err != nil {
		return nil, err
	}
	items := make([]struct {
		Key   K
		Value V
	}, len(keys))
	for i, key := range keys {
		value, err := m.Get(key)
		if err != nil {
			return nil, err
		}
		items[i].Key = key
		items[i].Value = value
	}
	return items, nil
}

func (m *TreeMap[K, V]) Clear() error {
	keys, err := m.Keys()
	if err != nil {
		return err
	}
	for _, key := range keys {
		err := m.Remove(key)
		if err != nil {
			return err
		}
	}
	return m.keys.Clear()
}

func (m *TreeMap[K, V]) MinKey() (K, error) {
	if m.keys.Length() == 0 {
		var zero K
		return zero, errors.New(CollectionErrMapEmpty)
	}
	keyData, err := m.keys.Get(0)
	if err != nil {
		var zero K
		return zero, err
	}
	var key K
	err = m.serializer.Deserialize(keyData, &key)
	if err != nil {
		var zero K
		return zero, err
	}
	return key, nil
}

func (m *TreeMap[K, V]) MaxKey() (K, error) {
	length := m.keys.Length()
	if length == 0 {
		var zero K
		return zero, errors.New(CollectionErrMapEmpty)
	}
	keyData, err := m.keys.Get(length - 1)
	if err != nil {
		var zero K
		return zero, err
	}
	var key K
	err = m.serializer.Deserialize(keyData, &key)
	if err != nil {
		var zero K
		return zero, err
	}
	return key, nil
}

func (m *TreeMap[K, V]) FloorKey(key K) (K, error) {
	length := m.keys.Length()
	if length == 0 {
		var zero K
		return zero, nil
	}
	left, right := 0, int(length)-1
	var result K
	found := false
	for left <= right {
		mid := (left + right) / 2
		keyData, err := m.keys.Get(uint64(mid))
		if err != nil {
			var zero K
			return zero, err
		}
		var midKey K
		err = m.serializer.Deserialize(keyData, &midKey)
		if err != nil {
			var zero K
			return zero, err
		}
		cmp := compareKeys(midKey, key)
		if cmp == 0 {
			return midKey, nil
		} else if cmp < 0 {
			result = midKey
			found = true
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	if found {
		return result, nil
	}
	var zero K
	return zero, nil
}

func (m *TreeMap[K, V]) CeilingKey(key K) (K, error) {
	length := m.keys.Length()
	if length == 0 {
		var zero K
		return zero, nil
	}
	left, right := 0, int(length)-1
	var result K
	found := false
	for left <= right {
		mid := (left + right) / 2
		keyData, err := m.keys.Get(uint64(mid))
		if err != nil {
			var zero K
			return zero, err
		}
		var midKey K
		err = m.serializer.Deserialize(keyData, &midKey)
		if err != nil {
			var zero K
			return zero, err
		}
		cmp := compareKeys(midKey, key)
		if cmp == 0 {
			return midKey, nil
		} else if cmp > 0 {
			result = midKey
			found = true
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	if found {
		return result, nil
	}
	var zero K
	return zero, nil
}

func (m *TreeMap[K, V]) Range(fromKey *K, toKey *K) ([]K, error) {
	allKeys, err := m.Keys()
	if err != nil {
		return nil, err
	}
	startIdx := 0
	endIdx := len(allKeys)
	if fromKey != nil {
		for i, key := range allKeys {
			if compareKeys(key, *fromKey) >= 0 {
				startIdx = i
				break
			}
		}
	}
	if toKey != nil {
		for i, key := range allKeys[startIdx:] {
			if compareKeys(key, *toKey) >= 0 {
				endIdx = startIdx + i
				break
			}
		}
	}
	return allKeys[startIdx:endIdx], nil
}

func compareKeys(a, b interface{}) int {
	switch a := a.(type) {
	case string:
		if b, ok := b.(string); ok {
			if a < b {
				return -1
			} else if a > b {
				return 1
			}
			return 0
		}
	case int:
		if b, ok := b.(int); ok {
			if a < b {
				return -1
			} else if a > b {
				return 1
			}
			return 0
		}
	case uint64:
		if b, ok := b.(uint64); ok {
			if a < b {
				return -1
			} else if a > b {
				return 1
			}
			return 0
		}
	}
	env.PanicStr(CollectionErrUnsupportedKeyType)
	return 0
}



==================================================
FILE: collections/collections_test.go
==================================================

package collections

import (
	"testing"

	"github.com/vlmoon99/near-sdk-go/env"
	"github.com/vlmoon99/near-sdk-go/system"
)

func init() {
	env.SetEnv(system.NewMockSystem())
}

func cleanupStorage(t *testing.T) {
	t.Helper()
	mockSys := env.NearBlockchainImports.(*system.MockSystem)
	for k := range mockSys.Storage {
		delete(mockSys.Storage, k)
	}
}

func TestVector_Push_Get(t *testing.T) {
	defer cleanupStorage(t)
	v := NewVector[string]("test_vector")

	testValue := "test_value"
	err := v.Push(testValue)
	if err != nil {
		t.Fatalf("Push failed: %v", err)
	}

	retrievedValue, err := v.Get(0)
	if err != nil {
		t.Fatalf("Get failed: %v", err)
	}

	if retrievedValue != testValue {
		t.Fatalf("Expected value %v, got %v", testValue, retrievedValue)
	}
}

func TestVector_Length(t *testing.T) {
	defer cleanupStorage(t)
	v := NewVector[string]("test_vector")

	if v.Length() != 0 {
		t.Fatalf("Expected initial length 0, got %d", v.Length())
	}

	err := v.Push("value1")
	if err != nil {
		t.Fatalf("Push failed: %v", err)
	}

	if v.Length() != 1 {
		t.Fatalf("Expected length 1, got %d", v.Length())
	}

	err = v.Push("value2")
	if err != nil {
		t.Fatalf("Push failed: %v", err)
	}

	if v.Length() != 2 {
		t.Fatalf("Expected length 2, got %d", v.Length())
	}
}

func TestVector_Pop(t *testing.T) {
	defer cleanupStorage(t)
	v := NewVector[string]("test_vector")

	_, err := v.Pop()
	if err == nil {
		t.Fatalf("Expected error on empty vector pop")
	}

	testValue := "test_value"
	err = v.Push(testValue)
	if err != nil {
		t.Fatalf("Push failed: %v", err)
	}

	value, err := v.Pop()
	if err != nil {
		t.Fatalf("Pop failed: %v", err)
	}

	if value != testValue {
		t.Fatalf("Expected value %v, got %v", testValue, value)
	}

	if v.Length() != 0 {
		t.Fatalf("Expected length 0 after pop, got %d", v.Length())
	}
}

func TestLookupMap_Insert_Get(t *testing.T) {
	defer cleanupStorage(t)
	m := NewLookupMap[string, string]("test_map")

	key := "test_key"
	value := "test_value"

	err := m.Insert(key, value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	retrievedValue, err := m.Get(key)
	if err != nil {
		t.Fatalf("Get failed: %v", err)
	}

	if retrievedValue != value {
		t.Fatalf("Expected value %v, got %v", value, retrievedValue)
	}
}

func TestLookupMap_Contains(t *testing.T) {
	defer cleanupStorage(t)
	m := NewLookupMap[string, string]("test_map")

	key := "test_key"
	value := "test_value"

	exists, err := m.Contains(key)
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if exists {
		t.Fatalf("Expected key to not exist")
	}

	err = m.Insert(key, value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	exists, err = m.Contains(key)
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if !exists {
		t.Fatalf("Expected key to exist")
	}
}

func TestLookupMap_Remove(t *testing.T) {
	defer cleanupStorage(t)
	m := NewLookupMap[string, string]("test_map")

	key := "test_key"
	value := "test_value"

	err := m.Insert(key, value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	err = m.Remove(key)
	if err != nil {
		t.Fatalf("Remove failed: %v", err)
	}

	exists, err := m.Contains(key)
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if exists {
		t.Fatalf("Expected key to not exist after removal")
	}
}

func TestLookupMap_MultipleValues(t *testing.T) {
	defer cleanupStorage(t)
	m := NewLookupMap[string, string]("test_map")

	testData := map[string]string{
		"key1": "value1",
		"key2": "value2",
		"key3": "value3",
	}

	for k, v := range testData {
		err := m.Insert(k, v)
		if err != nil {
			t.Fatalf("Insert failed for key %s: %v", k, err)
		}
	}

	for k, expected := range testData {
		value, err := m.Get(k)
		if err != nil {
			t.Fatalf("Get failed for key %s: %v", k, err)
		}
		if value != expected {
			t.Fatalf("Expected value %s for key %s, got %s", expected, k, value)
		}
	}
}

func TestLookupMap_StructValues(t *testing.T) {
	defer cleanupStorage(t)
	type TestValue struct {
		Data string
		Num  int
	}

	m := NewLookupMap[string, TestValue]("test_map")

	value := TestValue{Data: "test", Num: 42}
	err := m.Insert("key1", value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	retrieved, err := m.Get("key1")
	if err != nil {
		t.Fatalf("Get failed: %v", err)
	}
	if retrieved != value {
		t.Fatalf("Expected value %+v, got %+v", value, retrieved)
	}
}

func TestLookupMap_ErrorCases(t *testing.T) {
	defer cleanupStorage(t)
	m := NewLookupMap[string, int]("test_map")

	_, err := m.Get("non_existent")
	if err == nil {
		t.Fatalf("Expected error when getting non-existent key")
	}

	err = m.Remove("non_existent")
	if err == nil {
		t.Fatalf("Expected error when removing non-existent key: %v", err)
	}

	exists, err := m.Contains("non_existent")
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if exists {
		t.Fatalf("Expected non-existent key to not exist")
	}
}

func TestUnorderedMap_Insert_Get(t *testing.T) {
	defer cleanupStorage(t)
	m := NewUnorderedMap[string, string]("test_map")

	key := "test_key"
	value := "test_value"

	err := m.Insert(key, value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	retrievedValue, err := m.Get(key)
	if err != nil {
		t.Fatalf("Get failed: %v", err)
	}

	if retrievedValue != value {
		t.Fatalf("Expected value %v, got %v", value, retrievedValue)
	}
}

func TestUnorderedMap_Contains(t *testing.T) {
	defer cleanupStorage(t)
	m := NewUnorderedMap[string, string]("test_map")

	key := "test_key"
	value := "test_value"

	exists, err := m.Contains(key)

	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if exists {
		t.Fatalf("Expected key to not exist")
	}

	err = m.Insert(key, value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	exists, err = m.Contains(key)
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if !exists {
		t.Fatalf("Expected key to exist")
	}
}

func TestUnorderedMap_Remove(t *testing.T) {
	defer cleanupStorage(t)

	m := NewUnorderedMap[string, string]("test_map")

	key := "test_key"
	value := "test_value"

	err := m.Insert(key, value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	err = m.Remove(key)
	if err != nil {
		t.Fatalf("Remove failed: %v", err)
	}

	exists, err := m.Contains(key)
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if exists {
		t.Fatalf("Expected key to not exist after removal")
	}
}

func TestUnorderedMap_Keys_Values(t *testing.T) {
	defer cleanupStorage(t)

	m := NewUnorderedMap[string, string]("test_map")

	testData := map[string]string{
		"key1": "value1",
		"key2": "value2",
		"key3": "value3",
	}

	for k, v := range testData {
		err := m.Insert(k, v)
		if err != nil {
			t.Fatalf("Insert failed for key %s: %v", k, err)
		}
	}

	keys, err := m.Keys()
	if err != nil {
		t.Fatalf("Keys failed: %v", err)
	}
	if len(keys) != len(testData) {
		t.Fatalf("Expected %d keys, got %d", len(testData), len(keys))
	}

	values, err := m.Values()
	if err != nil {
		t.Fatalf("Values failed: %v", err)
	}
	if len(values) != len(testData) {
		t.Fatalf("Expected %d values, got %d", len(testData), len(values))
	}
}

func TestLookupSet_Insert_Contains(t *testing.T) {
	defer cleanupStorage(t)

	s := NewLookupSet[string]("test_set")

	value := "test_value"

	exists, err := s.Contains(value)
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if exists {
		t.Fatalf("Expected value to not exist")
	}

	err = s.Insert(value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	exists, err = s.Contains(value)
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if !exists {
		t.Fatalf("Expected value to exist")
	}
}

func TestLookupSet_Remove(t *testing.T) {
	defer cleanupStorage(t)

	s := NewLookupSet[string]("test_set")

	value := "test_value"

	err := s.Insert(value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	err = s.Remove(value)
	if err != nil {
		t.Fatalf("Remove failed: %v", err)
	}

	exists, err := s.Contains(value)
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if exists {
		t.Fatalf("Expected value to not exist after removal")
	}
}

func TestUnorderedSet_Insert_Contains(t *testing.T) {
	defer cleanupStorage(t)

	s := NewUnorderedSet[string]("test_set")

	value := "test_value"

	exists, err := s.Contains(value)
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if exists {
		t.Fatalf("Expected value to not exist")
	}

	err = s.Insert(value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	exists, err = s.Contains(value)
	if err != nil {
		t.Fatalf("Contains failed: %v", err)
	}
	if !exists {
		t.Fatalf("Expected value to exist")
	}
}

func TestUnorderedSet_Values(t *testing.T) {
	defer cleanupStorage(t)

	s := NewUnorderedSet[string]("test_set")

	testValues := []string{"value1", "value2", "value3"}

	for _, v := range testValues {
		err := s.Insert(v)
		if err != nil {
			t.Fatalf("Insert failed for value %s: %v", v, err)
		}
	}

	values, err := s.Values(0, nil)
	if err != nil {
		t.Fatalf("Values failed: %v", err)
	}
	if len(values) != len(testValues) {
		t.Fatalf("Expected %d values, got %d", len(testValues), len(values))
	}
}

func TestTreeMap_Insert_Get(t *testing.T) {
	defer cleanupStorage(t)

	m := NewTreeMap[string, string]("test_map")

	key := "test_key"
	value := "test_value"

	err := m.Insert(key, value)
	if err != nil {
		t.Fatalf("Insert failed: %v", err)
	}

	retrievedValue, err := m.Get(key)
	if err != nil {
		t.Fatalf("Get failed: %v", err)
	}

	if retrievedValue != value {
		t.Fatalf("Expected value %v, got %v", value, retrievedValue)
	}
}

func TestTreeMap_MinKey_MaxKey(t *testing.T) {
	defer cleanupStorage(t)

	m := NewTreeMap[string, string]("test_map")

	env.LogString("TestTreeMap_MinKey_MaxKey: Testing empty map MinKey")
	_, err := m.MinKey()
	if err == nil {
		t.Fatalf("Expected error for empty map MinKey")
	}
	if err.Error() != CollectionErrMapEmpty {
		t.Fatalf("Expected error %s, got %s", CollectionErrMapEmpty, err.Error())
	}

	env.LogString("TestTreeMap_MinKey_MaxKey: Testing empty map MaxKey")
	_, err = m.MaxKey()
	if err == nil {
		t.Fatalf("Expected error for empty map MaxKey")
	}
	if err.Error() != CollectionErrMapEmpty {
		t.Fatalf("Expected error %s, got %s", CollectionErrMapEmpty, err.Error())
	}

	testData := map[string]string{
		"key1": "value1",
		"key2": "value2",
		"key3": "value3",
	}

	env.LogString("TestTreeMap_MinKey_MaxKey: Inserting test data")
	for k, v := range testData {
		err := m.Insert(k, v)
		if err != nil {
			t.Fatalf("Insert failed for key %s: %v", k, err)
		}
	}

	env.LogString("TestTreeMap_MinKey_MaxKey: Testing MinKey")
	minKey, err := m.MinKey()
	if err != nil {
		t.Fatalf("MinKey failed: %v", err)
	}

	if minKey != "key1" {
		t.Fatalf("Expected min key 'key1', got %v", minKey)
	}

	env.LogString("TestTreeMap_MinKey_MaxKey: Testing MaxKey")
	maxKey, err := m.MaxKey()
	if err != nil {
		t.Fatalf("MaxKey failed: %v", err)
	}
	if maxKey != "key3" {
		t.Fatalf("Expected max key 'key3', got %v", maxKey)
	}
}

func TestTreeMap_FloorKey_CeilingKey(t *testing.T) {
	defer cleanupStorage(t)

	m := NewTreeMap[string, string]("test_map")

	testData := map[string]string{
		"key1": "value1",
		"key3": "value3",
		"key5": "value5",
	}

	for k, v := range testData {
		err := m.Insert(k, v)
		if err != nil {
			t.Fatalf("Insert failed for key %s: %v", k, err)
		}
	}

	floorKey, err := m.FloorKey("key4")
	if err != nil {
		t.Fatalf("FloorKey failed: %v", err)
	}
	if floorKey != "key3" {
		t.Fatalf("Expected floor key 'key3', got %v", floorKey)
	}

	ceilingKey, err := m.CeilingKey("key2")
	if err != nil {
		t.Fatalf("CeilingKey failed: %v", err)
	}
	if ceilingKey != "key3" {
		t.Fatalf("Expected ceiling key 'key3', got %v", ceilingKey)
	}
}



==================================================
FILE: contract/contract.go
==================================================

package contract

import (
	"encoding/json"
	"errors"

	"github.com/vlmoon99/near-sdk-go/env"
	"github.com/vlmoon99/near-sdk-go/promise"
	"github.com/vlmoon99/near-sdk-go/types"
)

func HandleClientJSONInput(fn func(*ContractInput) error) {
	input, err := GetJSONInput()
	if err != nil {
		env.PanicStr("failed to get input: " + err.Error())
	}
	if err := fn(input); err != nil {
		env.PanicStr(err.Error())
	}
}

func HandleClientRawBytesInput(fn func(*ContractInput) error) {
	input, err := GetRawBytesInput()
	if err != nil {
		env.PanicStr("failed to get input: " + err.Error())
	}
	if err := fn(input); err != nil {
		env.PanicStr(err.Error())
	}
}

func HandlePromiseResult(fn func(*promise.PromiseResult) error) {
	if err := promise.CallbackGuard(); err != nil {
		env.PanicStr("callback rejected: " + err.Error())
	}

	result, err := promise.GetPromiseResultSafe(0)
	if err != nil {
		env.PanicStr("failed to get promise result: " + err.Error())
	}

	if err := fn(&result); err != nil {
		env.PanicStr(err.Error())
	}
}

func ReturnValue(value interface{}) error {
	var data []byte
	var err error

	switch v := value.(type) {
	case []byte:
		data = v
	default:
		data, err = json.Marshal(v)
		if err != nil {
			return err
		}
	}

	env.ContractValueReturn(data)
	return nil
}

type ContractInput struct {
	Data []byte
}

func GetJSONInput() (*ContractInput, error) {
	options := types.ContractInputOptions{IsRawBytes: false}
	data, _, err := env.ContractInput(options)
	if err != nil {
		return nil, err
	}

	return &ContractInput{
		Data: data,
	}, nil
}

func GetRawBytesInput() (*ContractInput, error) {
	options := types.ContractInputOptions{IsRawBytes: true}
	data, _, err := env.ContractInput(options)
	if err != nil {
		return nil, err
	}

	return &ContractInput{
		Data: data,
	}, nil
}

type ContractContext struct {
	AccountID       string
	SignerID        string
	PredecessorID   string
	AttachedDeposit types.Uint128
	PrepaidGas      uint64
}

func GetContext() *ContractContext {
	accountID, _ := env.GetCurrentAccountId()
	signerID, _ := env.GetSignerAccountID()
	predecessorID, _ := env.GetPredecessorAccountID()
	attachedDeposit, _ := env.GetAttachedDeposit()
	prepaidGas := env.GetPrepaidGas()

	return &ContractContext{
		AccountID:       accountID,
		SignerID:        signerID,
		PredecessorID:   predecessorID,
		AttachedDeposit: attachedDeposit,
		PrepaidGas:      prepaidGas.Inner,
	}
}

func RequireDeposit(minDeposit types.Uint128) error {
	context := GetContext()
	if context.AttachedDeposit.Lo < minDeposit.Lo ||
		(context.AttachedDeposit.Lo == minDeposit.Lo && context.AttachedDeposit.Hi < minDeposit.Hi) {
		return errors.New("insufficient deposit")
	}
	return nil
}

type PromiseResult struct {
	Success    bool
	Data       []byte
	StatusCode int
}



==================================================
FILE: contract/contract_test.go
==================================================

package contract

import (
	"testing"

	"encoding/json"

	"github.com/vlmoon99/near-sdk-go/env"
	"github.com/vlmoon99/near-sdk-go/system"
	"github.com/vlmoon99/near-sdk-go/types"
)

func init() {
	systemMock := system.NewMockSystem()

	expectedAccountID := "test.account"
	expectedSignerID := "test.signer"
	expectedPredecessorID := "test.predecessor"
	expectedGas := uint64(1000)
	expectedDeposit, _ := types.U128FromString("10000000000000000000000000")

	systemMock.CurrentAccountIdSys = expectedAccountID
	systemMock.SignerAccountIdSys = expectedSignerID
	systemMock.PredecessorAccountIdSys = expectedPredecessorID
	systemMock.AttachedDepositSys = expectedDeposit
	systemMock.PrepaidGasSys = expectedGas

	env.SetEnv(systemMock)
}

type TestStruct struct {
	Value string
}

func (t TestStruct) Serialize() ([]byte, error) {
	return json.Marshal(t)
}

func TestReturnValue(t *testing.T) {
	tests := []struct {
		name     string
		input    interface{}
		expected []byte
		wantErr  bool
	}{
		{
			name:     "Return byte array",
			input:    []byte("test"),
			expected: []byte("test"),
			wantErr:  false,
		},
		{
			name:     "Return serializable struct",
			input:    TestStruct{Value: "test"},
			expected: []byte("test"),
			wantErr:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ReturnValue(tt.input)
			if (err != nil) != tt.wantErr {
				t.Errorf("ReturnValue() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}

func TestGetContext(t *testing.T) {
	expectedAccountID := "test.account"
	expectedSignerID := "test.signer"
	expectedPredecessorID := "test.predecessor"
	expectedGas := uint64(1000)
	expectedDeposit, _ := types.U128FromString("10000000000000000000000000")

	context := GetContext()

	if context.AccountID != expectedAccountID {
		t.Errorf("GetContext().AccountID = %v, want %v", context.AccountID, expectedAccountID)
	}
	if context.SignerID != expectedSignerID {
		t.Errorf("GetContext().SignerID = %v, want %v", context.SignerID, expectedSignerID)
	}
	if context.PredecessorID != expectedPredecessorID {
		t.Errorf("GetContext().PredecessorID = %v, want %v", context.PredecessorID, expectedPredecessorID)
	}
	if context.AttachedDeposit != expectedDeposit {
		t.Errorf("GetContext().AttachedDeposit = %v, want %v", context.AttachedDeposit, expectedDeposit)
	}
	if context.PrepaidGas != expectedGas {
		t.Errorf("GetContext().PrepaidGas = %v, want %v", context.PrepaidGas, expectedGas)
	}
}

func TestRequireDeposit(t *testing.T) {
	equalDeposit, _ := types.U128FromString("10000000000000000000000000")
	sufficientDeposit, _ := types.U128FromString("11000000000000000000000000")
	insufficientDeposit, _ := types.U128FromString("1000")

	tests := []struct {
		name            string
		minDeposit      types.Uint128
		attachedDeposit types.Uint128
		wantErr         bool
	}{
		{
			name:            "Sufficient deposit",
			minDeposit:      equalDeposit,
			attachedDeposit: sufficientDeposit,
			wantErr:         false,
		},
		{
			name:            "Insufficient deposit",
			minDeposit:      equalDeposit,
			attachedDeposit: insufficientDeposit,
			wantErr:         true,
		},
		{
			name:            "Equal deposit",
			minDeposit:      equalDeposit,
			attachedDeposit: equalDeposit,
			wantErr:         false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockSys := env.NearBlockchainImports.(*system.MockSystem)
			mockSys.AttachedDepositSys = tt.attachedDeposit

			err := RequireDeposit(tt.minDeposit)
			if (err != nil) != tt.wantErr {
				t.Errorf("RequireDeposit() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestHandleClientJSONInput(t *testing.T) {
	mockSys := env.NearBlockchainImports.(*system.MockSystem)
	jsonData := []byte(`{"test": "value"}`)
	mockSys.ContractInput = jsonData

	success := false
	HandleClientJSONInput(func(input *ContractInput) error {
		success = true
		return nil
	})

	if !success {
		t.Error("HandleClientJSONInput() did not execute callback")
	}

}

func TestHandleClientRawBytesInput(t *testing.T) {
	mockSys := env.NearBlockchainImports.(*system.MockSystem)
	rawData := []byte("raw bytes")
	mockSys.ContractInput = rawData

	success := false
	HandleClientRawBytesInput(func(input *ContractInput) error {
		success = true
		return nil
	})

	if !success {
		t.Error("HandleClientRawBytesInput() did not execute callback")
	}

}



==================================================
FILE: doc/README.md
==================================================

ðŸ’¡ **This is the enhanced documentation where you'll find detailed instructions about this repository â€” including how to use it, build smart contracts, connect them to the frontend, and more.**


==================================================
FILE: env/env.go
==================================================

// This package provides implementations of low-level blockchain functions.
// Under the hood, it uses the system package, which provides raw environment imports from the Near Blockchain environment.
// Here, we wrap these functions and provide simpler methods for using low-level environment functions for smart contract development.
// For examples, please go to examples/integration_tests/main.go to see how these functions are called.
// All these functions are tested in integration_tests/src/main.rs. It's the best way to understand how they work in real examples.
package env

import (
	"errors"
	"math"
	"unsafe"

	"github.com/vlmoon99/jsonparser"
	"github.com/vlmoon99/near-sdk-go/system"
	"github.com/vlmoon99/near-sdk-go/types"
)

const RegisterExpectedErr = "Register was expected to have data because we just wrote it into it."

const AtomicOpRegister uint64 = math.MaxUint64 - 2

const EvictedRegister uint64 = math.MaxUint64 - 1

const DataIdRegister = 0

var StateKey = []byte("STATE")

const MinAccountIDLen uint64 = 2

const MaxAccountIDLen uint64 = 64

var NearBlockchainImports system.System = system.SystemNear{}

const (
	ErrExpectedDataInRegister            = "(REGISTER_ERROR): expected data in register, but found none"
	ErrInvalidAccountID                  = "(ACCOUNT_ERROR): invalid account ID"
	ErrKeyNotFound                       = "(STORAGE_ERROR): key not found"
	ErrValueNotFound                     = "(STORAGE_ERROR): value not found"
	ErrFailedToParseInput                = "(INPUT_ERROR): failed to parse input"
	ErrUnsupportedDataFormat             = "(FORMAT_ERROR): unsupported data format"
	ErrGettingAccountBalance             = "(BALANCE_ERROR): error while getting account balance"
	ErrGettingLockedAccountBalance       = "(BALANCE_ERROR): error while getting locked account balance"
	ErrGettingAttachedDeposit            = "(DEPOSIT_ERROR): error while getting attached deposit"
	ErrFailedToWriteValueInStorage       = "(STORAGE_ERROR): failed to write value in the storage by provided key, result of operation is 0"
	ErrKeyIsEmpty                        = "(STORAGE_ERROR): key is empty"
	ErrFailedToReadKey                   = "(STORAGE_ERROR): failed to read the key"
	ErrFailedToReadRegister              = "(REGISTER_ERROR): failed to read register"
	ErrCantRemoveDataByKey               = "(STORAGE_ERROR): can't remove data by that key"
	ErrFailedToReadEvictedRegister       = "(REGISTER_ERROR): failed to read evicted register"
	ErrStateNotFound                     = "(STATE_ERROR): state not found"
	ErrFailedToWriteStateToStorage       = "(STORAGE_ERROR): failed to write state to storage"
	ErrInvalidInputHashAndSignatureEmpty = "(INPUT_ERROR): invalid input: hash and signature must not be empty"
	PanicStrEcrecoverFailed              = "(PANIC): Ecrecover failed"
	ErrAccountIDMustNotBeEmpty           = "(ACCOUNT_ERROR): account ID must not be empty"
	ErrGettingValidatorStakeAmount       = "(STAKE_ERROR): error while getting validator stake amount"
	ErrGettingValidatorTotalStakeAmount  = "(STAKE_ERROR): error while getting validator total stake amount"
	ErrPromiseResult                     = "(PROMISE_ERROR): no promise results available"
)

// SetEnv sets the environment to be used for Near Blockchain imports.
// It can be a mocked environment for unit tests or the default Near Blockchain imports for production.
//
// Parameters:
// - system: The system environment to be set.
func SetEnv(system system.System) {
	NearBlockchainImports = system
}

// Registers API

// tryMethodIntoRegister tries to execute the given method and reads the data from the register.
//
// Parameters:
// - method: The method to be executed.
//
// Returns:
// - []byte: The data read from the register.
// - error: An error if the method execution or data reading fails.
func tryMethodIntoRegister(method func(uint64)) ([]byte, error) {
	method(AtomicOpRegister)

	return ReadRegisterSafe(AtomicOpRegister)
}

// methodIntoRegister executes the given method and ensures the data is read from the register.
//
// Parameters:
// - method: The method to be executed.
//
// Returns:
// - []byte: The data read from the register.
// - error: An error if the method execution or data reading fails.
func methodIntoRegister(method func(uint64)) ([]byte, error) {
	data, err := tryMethodIntoRegister(method)
	if err != nil {
		return nil, err
	}
	if len(data) == 0 {
		return nil, errors.New(ErrExpectedDataInRegister)
	}
	return data, nil
}

// ReadRegisterSafe reads the data from the specified register safely.
//
// Parameters:
// - registerId: The ID of the register to read from.
//
// Returns:
// - []byte: The data read from the register, or an error if the register reading fails.
func ReadRegisterSafe(registerId uint64) ([]byte, error) {
	length := NearBlockchainImports.RegisterLen(registerId)
	//TODO: If len == 0 - ExecutionError("WebAssembly trap: An `unreachable` opcode was executed.") for some reason, if we convert value into string, error gone
	assertValidAccountId([]byte(string(length)))
	if length == 0 {
		return []byte{}, errors.New(ErrExpectedDataInRegister)
	}
	buffer := make([]byte, length)
	ptr := uint64(uintptr(unsafe.Pointer(&buffer[0])))
	NearBlockchainImports.ReadRegister(registerId, ptr)
	return buffer, nil
}

// WriteRegisterSafe writes the given data to the specified register safely.
//
// Parameters:
// - registerId: The ID of the register to write to.
// - data: The data to be written to the register.
func WriteRegisterSafe(registerId uint64, data []byte) {
	if len(data) == 0 {
		return
	}

	ptr := uint64(uintptr(unsafe.Pointer(&data[0])))

	NearBlockchainImports.WriteRegister(registerId, uint64(len(data)), ptr)
}

// Registers API

// Storage API

// StorageWrite writes the given value to the specified key in storage.
//
// Parameters:
// - key: The key to write the value to.
// - value: The value to write.
//
// Returns:
// - bool: True if the value was successfully written, false otherwise.
// - error: An error if the key or value is empty or if the write operation fails.
func StorageWrite(key, value []byte) (bool, error) {
	if len(key) == 0 {
		return false, errors.New(ErrKeyNotFound)
	}

	if len(value) == 0 {
		return false, errors.New(ErrValueNotFound)
	}

	keyLen := uint64(len(key))
	keyPtr := uint64(uintptr(unsafe.Pointer(&key[0])))

	valueLen := uint64(len(value))
	valuePtr := uint64(uintptr(unsafe.Pointer(&value[0])))

	return storageWriteRecursive(keyLen, keyPtr, valueLen, valuePtr, 0)
}

// storageWriteRecursive attempts to write the value to the specified key in storage recursively.
//
// Parameters:
// - keyLen: The length of the key.
// - keyPtr: The pointer to the key.
// - valueLen: The length of the value.
// - valuePtr: The pointer to the value.
// - attempt: The current attempt number.
//
// Returns:
// - bool: True if the value was successfully written, false otherwise.
// - error: An error if the write operation fails after the allowed attempts.
func storageWriteRecursive(keyLen uint64, keyPtr uint64, valueLen uint64, valuePtr uint64, attempt int) (bool, error) {
	result := NearBlockchainImports.StorageWrite(keyLen, keyPtr, valueLen, valuePtr, EvictedRegister)

	if result == 1 {
		return true, nil
	}

	if result == 0 && attempt < 1 {
		return storageWriteRecursive(keyLen, keyPtr, valueLen, valuePtr, attempt+1)
	}

	return false, errors.New(ErrFailedToWriteValueInStorage)
}

// StorageRead reads the value associated with the given key from storage.
//
// Parameters:
// - key: The key to read the value for.
//
// Returns:
// - []byte: The value associated with the key, or an error if the read operation fails.
func StorageRead(key []byte) ([]byte, error) {
	if len(key) == 0 {
		return nil, errors.New(ErrKeyIsEmpty)
	}
	keyLen := uint64(len(key))
	keyPtr := uint64(uintptr(unsafe.Pointer(&key[0])))
	result := NearBlockchainImports.StorageRead(keyLen, keyPtr, AtomicOpRegister)

	if result == 0 {
		return nil, errors.New(ErrFailedToReadKey)
	}

	value, err := ReadRegisterSafe(AtomicOpRegister)
	if err != nil {
		return nil, errors.New(ErrFailedToReadRegister)
	}

	return value, nil
}

// StorageRemove removes the value associated with the given key from storage.
//
// Parameters:
// - key: The key to remove.
//
// Returns:
// - bool: True if the value was successfully removed, false otherwise.
// - error: An error if the key is empty or if the remove operation fails.
func StorageRemove(key []byte) (bool, error) {
	if len(key) == 0 {
		return false, errors.New(ErrKeyIsEmpty)
	}

	keyLen := uint64(len(key))
	keyPtr := uint64(uintptr(unsafe.Pointer(&key[0])))

	result := NearBlockchainImports.StorageRemove(keyLen, keyPtr, EvictedRegister)
	if result == 0 {
		return false, errors.New(ErrCantRemoveDataByKey)
	}

	return true, nil
}

// StorageGetEvicted reads the value from the evicted register.
//
// Returns:
// - []byte: The value read from the evicted register, or an error if the read operation fails.
func StorageGetEvicted() ([]byte, error) {
	value, err := ReadRegisterSafe(EvictedRegister)
	if err != nil {
		return nil, errors.New(ErrFailedToReadEvictedRegister + " " + err.Error())
	}

	return value, nil
}

// StorageHasKey checks if the given key exists in storage.
//
// Parameters:
// - key: The key to check for existence.
//
// Returns:
// - bool: True if the key exists, false otherwise.
// - error: An error if the key is empty.
func StorageHasKey(key []byte) (bool, error) {
	if len(key) == 0 {
		return false, errors.New(ErrKeyIsEmpty)
	}

	keyLen := uint64(len(key))
	keyPtr := uint64(uintptr(unsafe.Pointer(&key[0])))

	result := NearBlockchainImports.StorageHasKey(keyLen, keyPtr)

	return result == 1, nil
}

// StateWrite writes the given data to the state.
//
// Parameters:
// - data: The data to write.
//
// Returns:
// - error: An error if the write operation fails.
func StateWrite(data []byte) error {

	keyLen := uint64(len(StateKey))
	keyPtr := uint64(uintptr(unsafe.Pointer(&StateKey[0])))

	valueLen := uint64(len(data))
	valuePtr := uint64(uintptr(unsafe.Pointer(&data[0])))

	_, err := storageWriteRecursive(keyLen, keyPtr, valueLen, valuePtr, 0)

	return err
}

// StateRead reads the data from the state.
//
// Returns:
// - []byte: The data read from the state, or an error if the read operation fails.
func StateRead() ([]byte, error) {
	keyLen := uint64(len(StateKey))
	keyPtr := uint64(uintptr(unsafe.Pointer(&StateKey[0])))

	result := NearBlockchainImports.StorageRead(keyLen, keyPtr, EvictedRegister)
	if result == 0 {
		return nil, errors.New(ErrStateNotFound)
	}

	data, err := ReadRegisterSafe(EvictedRegister)
	if err != nil {
		return nil, errors.New(ErrFailedToReadRegister)
	}

	return data, nil
}

// StateExists checks if the state exists.
//
// Returns:
// - bool: True if the state exists, false otherwise.
func StateExists() bool {
	keyLen := uint64(len(StateKey))
	keyPtr := uint64(uintptr(unsafe.Pointer(&StateKey[0])))

	result := NearBlockchainImports.StorageHasKey(keyLen, keyPtr)
	return result == 1
}

// Storage API

// Context API

// assertValidAccountId checks if the provided account ID is valid.
//
// Parameters:
// - data: The account ID data to validate.
//
// Returns:
// - string: The valid account ID as a string.
// - error: An error if the account ID is invalid.
func assertValidAccountId(data []byte) (string, error) {
	if len(data) == 0 {
		return "", errors.New(ErrInvalidAccountID)
	}
	return string(data), nil
}

// GetCurrentAccountId retrieves the current account ID.
//
// Returns:
// - string: The current account ID.
// - error: An error if the retrieval fails.
func GetCurrentAccountId() (string, error) {
	data, err := methodIntoRegister(func(registerID uint64) { NearBlockchainImports.CurrentAccountId(registerID) })
	if err != nil {
		LogString("Error in GetCurrentAccountId: " + err.Error())
		return "", err
	}

	return assertValidAccountId(data)
}

// GetSignerAccountID retrieves the signer account ID.
//
// Returns:
// - string: The signer account ID.
// - error: An error if the retrieval fails.
func GetSignerAccountID() (string, error) {
	data, err := methodIntoRegister(func(registerID uint64) { NearBlockchainImports.SignerAccountId(registerID) })
	if err != nil {
		LogString("Error in GetSignerAccountID: " + err.Error())
		return "", err
	}

	return assertValidAccountId(data)
}

// GetSignerAccountPK retrieves the public key of the signer account.
//
// Returns:
// - []byte: The public key of the signer account.
// - error: An error if the retrieval fails.
func GetSignerAccountPK() ([]byte, error) {
	data, err := methodIntoRegister(func(registerID uint64) { NearBlockchainImports.SignerAccountPk(registerID) })
	if err != nil {
		LogString("Error in GetSignerAccountPK: " + err.Error())
		return nil, err
	}

	return data, nil
}

// GetPredecessorAccountID retrieves the predecessor account ID.
//
// Returns:
// - string: The predecessor account ID.
// - error: An error if the retrieval fails.
func GetPredecessorAccountID() (string, error) {
	data, err := methodIntoRegister(func(registerID uint64) { NearBlockchainImports.PredecessorAccountId(registerID) })
	if err != nil {
		LogString("Error in GetPredecessorAccountID: " + err.Error())
		return "", err
	}

	return assertValidAccountId(data)
}

// GetCurrentBlockHeight retrieves the current block height.
//
// Returns:
// - uint64: The current block height.
func GetCurrentBlockHeight() uint64 {
	return NearBlockchainImports.BlockTimestamp()
}

// GetBlockTimeMs retrieves the block time in milliseconds.
//
// Returns:
// - uint64: The block time in milliseconds.
func GetBlockTimeMs() uint64 {
	return NearBlockchainImports.BlockTimestamp() / 1_000_000
}

// GetEpochHeight retrieves the current epoch height.
//
// Returns:
// - uint64: The current epoch height.
func GetEpochHeight() uint64 {
	return NearBlockchainImports.EpochHeight()
}

// GetStorageUsage retrieves the storage usage.
//
// Returns:
// - uint64: The storage usage.
func GetStorageUsage() uint64 {
	return NearBlockchainImports.StorageUsage()
}

// detectInputType detects the type of input data based on the provided key path.
//
// Parameters:
// - decodedData: The decoded data to analyze.
// - keyPath: The key path to locate the specific data element.
//
// Returns:
// - []byte: The detected value.
// - string: The type of the detected value.
// - error: An error if the detection fails.
func detectInputType(decodedData []byte, keyPath ...string) ([]byte, string, error) {
	value, dataType, _, err := jsonparser.Get(decodedData, keyPath...)

	if err != nil {
		if dataType == jsonparser.NotExist {
			return nil, "not_exist", errors.New(ErrKeyNotFound)
		}
		return nil, "unknown", errors.New(ErrFailedToParseInput)
	}

	switch dataType {
	case jsonparser.String:
		return value, "string", nil
	case jsonparser.Number:
		return value, "number", nil
	case jsonparser.Boolean:
		return value, "boolean", nil
	case jsonparser.Array:
		return value, "array", nil
	case jsonparser.Object:
		return value, "object", nil
	case jsonparser.Null:
		return nil, "null", nil
	default:
		return nil, "unknown", errors.New(ErrUnsupportedDataFormat)
	}
}

// ContractInput retrieves the input data for the contract.
//
// Parameters:
// - options: Options specifying how to handle the input data.
//
// Returns:
// - []byte: The input data.
// - string: The type of the input data.
// - error: An error if the retrieval or processing fails.
func ContractInput(options types.ContractInputOptions) ([]byte, string, error) {
	data, err := methodIntoRegister(func(registerID uint64) {
		NearBlockchainImports.Input(registerID)
	})
	if err != nil {
		LogString("Error in GetContractInput: " + err.Error())
		return nil, "", err
	}

	if options.IsRawBytes {
		return data, "rawBytes", nil
	}

	parsedData, detectedType, err := detectInputType(data)
	if err != nil {
		LogString("Failed to detect input type: " + err.Error())
		return nil, "", err
	}

	return parsedData, detectedType, nil
}

// Context API

// Economics API

// GetAccountBalance retrieves the current account balance.
//
// Returns:
// - types.Uint128: The current account balance.
// - error: An error if the retrieval fails.
func GetAccountBalance() (types.Uint128, error) {
	var data [16]byte
	NearBlockchainImports.AccountBalance(uint64(uintptr(unsafe.Pointer(&data[0]))))
	accountBalance, err := types.LoadUint128LE(data[:])
	if err != nil {
		return types.Uint128{Hi: 0, Lo: 0}, errors.New(ErrGettingAccountBalance)
	}
	return accountBalance, nil
}

// GetAccountLockedBalance retrieves the locked balance of the account.
//
// Returns:
// - types.Uint128: The locked balance of the account.
// - error: An error if the retrieval fails.
func GetAccountLockedBalance() (types.Uint128, error) {
	var data [16]byte
	NearBlockchainImports.AccountLockedBalance(uint64(uintptr(unsafe.Pointer(&data[0]))))
	accountBalance, err := types.LoadUint128LE(data[:])
	if err != nil {
		return types.Uint128{Hi: 0, Lo: 0}, errors.New(ErrGettingLockedAccountBalance)
	}
	return accountBalance, nil
}

// GetAttachedDeposit retrieves the attached deposit.
//
// Returns:
// - types.Uint128: The attached deposit.
// - error: An error if the retrieval fails.
func GetAttachedDeposit() (types.Uint128, error) {
	var data [16]byte
	NearBlockchainImports.AttachedDeposit(uint64(uintptr(unsafe.Pointer(&data[0]))))
	attachedDeposit, err := types.LoadUint128LE(data[:])
	if err != nil {
		return types.Uint128{Hi: 0, Lo: 0}, errors.New(ErrGettingAttachedDeposit)
	}
	return attachedDeposit, nil
}

// GetPrepaidGas retrieves the prepaid gas.
//
// Returns:
// - types.NearGas: The prepaid gas.
func GetPrepaidGas() types.NearGas {
	return types.NearGas{Inner: NearBlockchainImports.PrepaidGas()}
}

// GetUsedGas retrieves the used gas.
//
// Returns:
// - types.NearGas: The used gas.
func GetUsedGas() types.NearGas {
	return types.NearGas{Inner: NearBlockchainImports.UsedGas()}
}

// Economics API

// Math API

// GetRandomSeed retrieves a random seed from the blockchain.
//
// Returns:
// - []byte: The random seed.
// - error: An error if the retrieval fails.
func GetRandomSeed() ([]byte, error) {
	return methodIntoRegister(func(registerID uint64) {
		NearBlockchainImports.RandomSeed(registerID)
	})
}

// Sha256Hash computes the SHA-256 hash of the given data.
//
// Parameters:
// - data: The data to hash.
//
// Returns:
// - []byte: The SHA-256 hash of the data.
// - error: An error if the hashing fails.
func Sha256Hash(data []byte) ([]byte, error) {
	return methodIntoRegister(func(registerID uint64) {
		NearBlockchainImports.Sha256(uint64(len(data)), uint64(uintptr(unsafe.Pointer(&data[0]))), registerID)
	})
}

// Keccak256Hash computes the Keccak-256 hash of the given data.
//
// Parameters:
// - data: The data to hash.
//
// Returns:
// - []byte: The Keccak-256 hash of the data.
// - error: An error if the hashing fails.
func Keccak256Hash(data []byte) ([]byte, error) {
	return methodIntoRegister(func(registerID uint64) {
		NearBlockchainImports.Keccak256(uint64(len(data)), uint64(uintptr(unsafe.Pointer(&data[0]))), registerID)
	})
}

// Keccak512Hash computes the Keccak-512 hash of the given data.
//
// Parameters:
// - data: The data to hash.
//
// Returns:
// - []byte: The Keccak-512 hash of the data.
// - error: An error if the hashing fails.
func Keccak512Hash(data []byte) ([]byte, error) {
	return methodIntoRegister(func(registerID uint64) {
		NearBlockchainImports.Keccak512(uint64(len(data)), uint64(uintptr(unsafe.Pointer(&data[0]))), registerID)
	})
}

// Ripemd160Hash computes the RIPEMD-160 hash of the given data.
//
// Parameters:
// - data: The data to hash.
//
// Returns:
// - []byte: The RIPEMD-160 hash of the data.
// - error: An error if the hashing fails.
func Ripemd160Hash(data []byte) ([]byte, error) {
	return methodIntoRegister(func(registerID uint64) {
		NearBlockchainImports.Ripemd160(uint64(len(data)), uint64(uintptr(unsafe.Pointer(&data[0]))), registerID)
	})
}

// EcrecoverPubKey recovers the public key from the given hash and signature using the ECDSA algorithm.
//
// Parameters:
// - hash: The hash of the data.
// - signature: The signature of the data.
// - v: The recovery id (v).
// - malleabilityFlag: Indicates if malleable.
//
// Returns:
// - []byte: The recovered public key.
// - error: An error if the input hash or signature is empty, or if the recovery fails.
func EcrecoverPubKey(hash, signature []byte, v byte, malleabilityFlag bool) ([]byte, error) {
	if len(hash) == 0 || len(signature) == 0 {
		return nil, errors.New(ErrInvalidInputHashAndSignatureEmpty)
	}

	return methodIntoRegister(func(registerID uint64) {
		result := NearBlockchainImports.Ecrecover(
			uint64(len(hash)), uint64(uintptr(unsafe.Pointer(&hash[0]))),
			uint64(len(signature)), uint64(uintptr(unsafe.Pointer(&signature[0]))),
			uint64(v), types.BoolToUnit(malleabilityFlag), registerID,
		)

		if result == 0 {
			PanicStr(PanicStrEcrecoverFailed)
		}
	})
}

// Ed25519VerifySig verifies the Ed25519 signature of the given message with the public key.
//
// Parameters:
// - signature: The Ed25519 signature.
// - message: The message to verify.
// - publicKey: The Ed25519 public key.
//
// Returns:
// - bool: True if the signature is valid, false otherwise.
func Ed25519VerifySig(signature [64]byte, message []byte, publicKey [32]byte) bool {
	result := NearBlockchainImports.Ed25519Verify(
		uint64(len(signature)), uint64(uintptr(unsafe.Pointer(&signature[0]))),
		uint64(len(message)), uint64(uintptr(unsafe.Pointer(&message[0]))),
		uint64(len(publicKey)), uint64(uintptr(unsafe.Pointer(&publicKey[0]))),
	)
	return result == 1
}

// AltBn128G1MultiExp performs a multi-exponentiation on the given value using the alt_bn128 curve.
//
// Parameters:
// - value: The value to perform multi-exponentiation on.
//
// Returns:
// - []byte: The result of the multi-exponentiation.
// - error: An error if the operation fails.
func AltBn128G1MultiExp(value []byte) ([]byte, error) {
	return methodIntoRegister(func(registerID uint64) {
		NearBlockchainImports.AltBn128G1Multiexp(uint64(len(value)), uint64(uintptr(unsafe.Pointer(&value[0]))), registerID)
	})
}

// AltBn128G1Sum performs a summation on the given value using the alt_bn128 curve.
//
// Parameters:
// - value: The value to perform summation on.
//
// Returns:
// - []byte: The result of the summation.
// - error: An error if the operation fails.
func AltBn128G1Sum(value []byte) ([]byte, error) {
	return methodIntoRegister(func(registerID uint64) {
		NearBlockchainImports.AltBn128G1SumSystem(uint64(len(value)), uint64(uintptr(unsafe.Pointer(&value[0]))), registerID)
	})
}

// AltBn128PairingCheck performs a pairing check on the given value using the alt_bn128 curve.
//
// Parameters:
// - value: The value to perform pairing check on.
//
// Returns:
// - bool: True if the pairing check is successful, false otherwise.
func AltBn128PairingCheck(value []byte) bool {
	return NearBlockchainImports.AltBn128PairingCheckSystem(uint64(len(value)), uint64(uintptr(unsafe.Pointer(&value[0])))) == 1
}

// Math API

// Validator API

// ValidatorStakeAmount retrieves the stake amount for a given validator account ID.
//
// Parameters:
// - accountID: The account ID of the validator.
//
// Returns:
// - types.Uint128: The stake amount of the validator.
// - error: An error if the account ID is empty or if the retrieval fails.
func ValidatorStakeAmount(accountID []byte) (types.Uint128, error) {
	if len(accountID) == 0 {
		return types.Uint128{Hi: 0, Lo: 0}, errors.New(ErrAccountIDMustNotBeEmpty)
	}

	var stakeData [16]byte
	NearBlockchainImports.ValidatorStake(uint64(len(accountID)), uint64(uintptr(unsafe.Pointer(&accountID[0]))), uint64(uintptr(unsafe.Pointer(&stakeData[0]))))

	validatorStakeAmount, err := types.LoadUint128LE(stakeData[:])
	if err != nil {
		return types.Uint128{Hi: 0, Lo: 0}, errors.New(ErrGettingValidatorStakeAmount)
	}

	return validatorStakeAmount, nil
}

// ValidatorTotalStakeAmount retrieves the total stake amount of all validators.
//
// Returns:
// - types.Uint128: The total stake amount of all validators.
// - error: An error if the retrieval fails.
func ValidatorTotalStakeAmount() (types.Uint128, error) {
	var stakeData [16]byte
	NearBlockchainImports.ValidatorTotalStake(uint64(uintptr(unsafe.Pointer(&stakeData[0]))))

	validatorTotalStakeAmount, err := types.LoadUint128LE(stakeData[:])
	if err != nil {
		return types.Uint128{Hi: 0, Lo: 0}, errors.New(ErrGettingValidatorTotalStakeAmount)
	}

	return validatorTotalStakeAmount, nil
}

// Validator API

// Miscellaneous API

// ContractValueReturn returns the specified value to the contract caller.
//
// Parameters:
// - inputBytes: The value to return.
func ContractValueReturn(inputBytes []byte) {
	NearBlockchainImports.ValueReturn(uint64(len(inputBytes)), uint64(uintptr(unsafe.Pointer(&inputBytes[0]))))
}

// PanicStr triggers a panic with the specified message.
//
// Parameters:
// - input: The panic message.
func PanicStr(input string) {
	inputBytes := []byte(input)
	inputLength := uint64(len(inputBytes))

	if inputLength == 0 {
		return
	}

	inputPtr := uint64(uintptr(unsafe.Pointer(&inputBytes[0])))

	NearBlockchainImports.PanicUtf8(inputLength, inputPtr)
}

// AbortExecution aborts the execution of the contract.
func AbortExecution() {
	PanicStr("AbortExecution")
}

// LogString logs the specified string message.
//
// Parameters:
// - input: The string message to log.
func LogString(input string) {
	inputBytes := []byte(input)
	inputLength := uint64(len(inputBytes))

	if inputLength == 0 {
		return
	}

	inputPtr := uint64(uintptr(unsafe.Pointer(&inputBytes[0])))

	NearBlockchainImports.LogUtf8(inputLength, inputPtr)
}

// LogStringUtf8 logs the specified UTF-8 encoded string message.
//
// Parameters:
// - inputBytes: The UTF-8 encoded string message to log.
func LogStringUtf8(inputBytes []byte) {
	inputLength := uint64(len(inputBytes))

	inputPtr := uint64(uintptr(unsafe.Pointer(&inputBytes[0])))

	NearBlockchainImports.LogUtf8(inputLength, inputPtr)
}

// LogStringUtf16 logs the specified UTF-16 encoded string message.
//
// Parameters:
// - inputBytes: The UTF-16 encoded string message to log.
func LogStringUtf16(inputBytes []byte) {
	inputLength := uint64(len(inputBytes))

	inputPtr := uint64(uintptr(unsafe.Pointer(&inputBytes[0])))

	NearBlockchainImports.LogUtf16(inputLength, inputPtr)
}

// Miscellaneous API

// Promises API

// PromiseCreate creates a promise to call a specified function on a specified account.
//
// Parameters:
// - accountId: The ID of the account to call the function on.
// - functionName: The name of the function to call.
// - arguments: The arguments to pass to the function.
// - amount: The amount to attach to the call.
// - gas: The amount of gas to attach to the call.
//
// Returns:
// - uint64: The ID of the created promise.
func PromiseCreate(accountId []byte, functionName []byte, arguments []byte, amount types.Uint128, gas uint64) uint64 {
	if len(arguments) == 0 {
		arguments = []byte("{}")
	}
	return NearBlockchainImports.PromiseCreate(
		uint64(len(accountId)),
		uint64(uintptr(unsafe.Pointer(&accountId[0]))),

		uint64(len(functionName)),
		uint64(uintptr(unsafe.Pointer(&functionName[0]))),

		uint64(len(arguments)),
		uint64(uintptr(unsafe.Pointer(&arguments[0]))),

		uint64(uintptr(unsafe.Pointer(&amount.ToLE()[0]))),
		gas,
	)
}

// PromiseThen creates a dependent promise that will be executed after the initial promise resolves.
//
// Parameters:
// - promiseIdx: The ID of the initial promise.
// - accountId: The ID of the account to call the function on.
// - functionName: The name of the function to call.
// - arguments: The arguments to pass to the function.
// - amount: The amount to attach to the call.
// - gas: The amount of gas to attach to the call.
//
// Returns:
// - uint64: The ID of the created dependent promise.
func PromiseThen(promiseIdx uint64, accountId []byte, functionName []byte, arguments []byte, amount types.Uint128, gas uint64) uint64 {
	if len(arguments) == 0 {
		arguments = []byte("{}")
	}

	return NearBlockchainImports.PromiseThen(
		promiseIdx,
		uint64(len(accountId)),
		uint64(uintptr(unsafe.Pointer(&accountId[0]))),

		uint64(len(functionName)),
		uint64(uintptr(unsafe.Pointer(&functionName[0]))),

		uint64(len(arguments)),
		uint64(uintptr(unsafe.Pointer(&arguments[0]))),

		uint64(uintptr(unsafe.Pointer(&amount.ToLE()[0]))),
		gas,
	)
}

// PromiseAnd combines multiple promises into a single promise that will resolve when all the combined promises resolve.
//
// Parameters:
// - promiseIndices: The IDs of the promises to combine.
//
// Returns:
// - uint64: The ID of the combined promise.
func PromiseAnd(promiseIndices []uint64) uint64 {
	return NearBlockchainImports.PromiseAnd(uint64(uintptr(unsafe.Pointer(&promiseIndices[0]))), uint64(len(promiseIndices)))
}

// PromiseBatchCreate creates a batch promise for a specified account.
//
// Parameters:
// - accountId: The ID of the account to create the batch promise for.
//
// Returns:
// - uint64: The ID of the created batch promise.
func PromiseBatchCreate(accountId []byte) uint64 {
	return NearBlockchainImports.PromiseBatchCreate(uint64(len(accountId)), uint64(uintptr(unsafe.Pointer(&accountId[0]))))
}

// PromiseBatchThen creates a dependent batch promise that will be executed after the initial promise resolves.
//
// Parameters:
// - promiseIdx: The ID of the initial promise.
// - accountId: The ID of the account to create the dependent batch promise for.
//
// Returns:
// - uint64: The ID of the created dependent batch promise.
func PromiseBatchThen(promiseIdx uint64, accountId []byte) uint64 {
	return NearBlockchainImports.PromiseBatchThen(promiseIdx, uint64(len(accountId)), uint64(uintptr(unsafe.Pointer(&accountId[0]))))
}

// Promises API

// Promises API Action

// PromiseBatchActionCreateAccount creates a promise batch action to create a new account.
//
// Parameters:
// - promiseIdx: The ID of the promise batch.
func PromiseBatchActionCreateAccount(promiseIdx uint64) {
	NearBlockchainImports.PromiseBatchActionCreateAccount(promiseIdx)
}

// PromiseBatchActionDeployContract creates a promise batch action to deploy a contract.
//
// Parameters:
// - promiseIdx: The ID of the promise batch.
// - bytes: The contract code to deploy.
func PromiseBatchActionDeployContract(promiseIdx uint64, bytes []byte) {
	NearBlockchainImports.PromiseBatchActionDeployContract(promiseIdx, uint64(len(bytes)), uint64(uintptr(unsafe.Pointer(&bytes[0]))))
}

// PromiseBatchActionFunctionCall creates a promise batch action to call a function.
//
// Parameters:
// - promiseIdx: The ID of the promise batch.
// - functionName: The name of the function to call.
// - arguments: The arguments to pass to the function.
// - amount: The amount to attach to the call.
// - gas: The amount of gas to attach to the call.
func PromiseBatchActionFunctionCall(promiseIdx uint64, functionName []byte, arguments []byte, amount types.Uint128, gas uint64) {
	if len(arguments) == 0 {
		arguments = []byte("{}")
	}
	NearBlockchainImports.PromiseBatchActionFunctionCall(promiseIdx,
		uint64(len(functionName)),
		uint64(uintptr(unsafe.Pointer(&functionName[0]))),

		uint64(len(arguments)),
		uint64(uintptr(unsafe.Pointer(&arguments[0]))),

		uint64(uintptr(unsafe.Pointer(&amount.ToLE()[0]))),
		gas,
	)
}

// PromiseBatchActionFunctionCallWeight creates a promise batch action to call a function with a specified weight.
//
// Parameters:
// - promiseIdx: The ID of the promise batch.
// - functionName: The name of the function to call.
// - arguments: The arguments to pass to the function.
// - amount: The amount to attach to the call.
// - gas: The amount of gas to attach to the call.
// - weight: The weight of the call.
func PromiseBatchActionFunctionCallWeight(promiseIdx uint64, functionName []byte, arguments []byte, amount types.Uint128, gas uint64, weight uint64) {
	if len(arguments) == 0 {
		arguments = []byte("{}")
	}
	NearBlockchainImports.PromiseBatchActionFunctionCallWeight(promiseIdx,
		uint64(len(functionName)),
		uint64(uintptr(unsafe.Pointer(&functionName[0]))),

		uint64(len(arguments)),
		uint64(uintptr(unsafe.Pointer(&arguments[0]))),

		uint64(uintptr(unsafe.Pointer(&amount.ToLE()[0]))),
		gas,
		weight,
	)
}

// PromiseBatchActionTransfer creates a promise batch action to transfer an amount.
//
// Parameters:
// - promiseIdx: The ID of the promise batch.
// - amount: The amount to transfer.
func PromiseBatchActionTransfer(promiseIdx uint64, amount types.Uint128) {
	NearBlockchainImports.PromiseBatchActionTransfer(promiseIdx, uint64(uintptr(unsafe.Pointer(&amount.ToLE()[0]))))
}

// PromiseBatchActionStake creates a promise batch action to stake an amount.
//
// Parameters:
// - promiseIdx: The ID of the promise batch.
// - amount: The amount to stake.
// - publicKey: The public key to stake with.
func PromiseBatchActionStake(promiseIdx uint64, amount types.Uint128, publicKey []byte) {
	NearBlockchainImports.PromiseBatchActionStake(
		promiseIdx,
		uint64(uintptr(unsafe.Pointer(&amount.ToLE()[0]))),

		uint64(len(publicKey)),
		uint64(uintptr(unsafe.Pointer(&publicKey[0]))),
	)
}

// PromiseBatchActionAddKeyWithFullAccess creates a promise batch action to add a key with full access.
//
// Parameters:
// - promiseIdx: The ID of the promise batch.
// - publicKey: The public key to add.
// - nonce: The nonce for the key.
func PromiseBatchActionAddKeyWithFullAccess(promiseIdx uint64, publicKey []byte, nonce uint64) {
	NearBlockchainImports.PromiseBatchActionAddKeyWithFullAccess(
		promiseIdx,

		uint64(len(publicKey)),
		uint64(uintptr(unsafe.Pointer(&publicKey[0]))),

		nonce,
	)
}

// PromiseBatchActionAddKeyWithFunctionCall creates a promise batch action to add a key with function call access.
//
// Parameters:
// - promiseIdx: The ID of the promise batch.
// - publicKey: The public key to add.
// - nonce: The nonce for the key.
// - amount: The amount to attach to the call.
// - receiverId: The ID of the receiver account.
// - functionName: The name of the function to call.
func PromiseBatchActionAddKeyWithFunctionCall(promiseIdx uint64, publicKey []byte, nonce uint64, amount types.Uint128, receiverId []byte, functionName []byte) {
	NearBlockchainImports.PromiseBatchActionAddKeyWithFunctionCall(
		promiseIdx,

		uint64(len(publicKey)),
		uint64(uintptr(unsafe.Pointer(&publicKey[0]))),

		nonce,
		uint64(uintptr(unsafe.Pointer(&amount.ToLE()[0]))),

		uint64(len(receiverId)),
		uint64(uintptr(unsafe.Pointer(&receiverId[0]))),

		uint64(len(functionName)),
		uint64(uintptr(unsafe.Pointer(&functionName[0]))),
	)
}

// PromiseBatchActionDeleteKey creates a promise batch action to delete a key.
//
// Parameters:
// - promiseIdx: The ID of the promise batch.
// - publicKey: The public key to delete.
func PromiseBatchActionDeleteKey(promiseIdx uint64, publicKey []byte) {
	NearBlockchainImports.PromiseBatchActionDeleteKey(
		promiseIdx,

		uint64(len(publicKey)),
		uint64(uintptr(unsafe.Pointer(&publicKey[0]))),
	)
}

// PromiseBatchActionDeleteAccount creates a promise batch action to delete an account.
//
// Parameters:
// - promiseIdx: The ID of the promise batch.
// - beneficiaryId: The ID of the beneficiary account.
func PromiseBatchActionDeleteAccount(promiseIdx uint64, beneficiaryId []byte) {
	NearBlockchainImports.PromiseBatchActionDeleteAccount(
		promiseIdx,

		uint64(len(beneficiaryId)),
		uint64(uintptr(unsafe.Pointer(&beneficiaryId[0]))),
	)
}

// PromiseYieldCreate creates a yield promise to call a specified function.
//
// Parameters:
// - functionName: The name of the function to call.
// - arguments: The arguments to pass to the function.
// - gas: The amount of gas to attach to the call.
// - gasWeight: The weight of the gas.
//
// Returns:
// - uint64: The ID of the created yield promise.
func PromiseYieldCreate(functionName []byte, arguments []byte, gas uint64, gasWeight uint64) uint64 {
	if len(arguments) == 0 {
		arguments = []byte("{}")
	}
	return NearBlockchainImports.PromiseYieldCreate(
		uint64(len(functionName)),
		uint64(uintptr(unsafe.Pointer(&functionName[0]))),

		uint64(len(arguments)),
		uint64(uintptr(unsafe.Pointer(&arguments[0]))),
		gas,
		gasWeight,
		DataIdRegister,
	)
}

// PromiseYieldResume resumes a yield promise with the specified data and payload.
//
// Parameters:
// - data: The data to resume the promise with.
// - payload: The payload to resume the promise with.
//
// Returns:
// - uint32: The status of the resumed promise.
func PromiseYieldResume(data []byte, payload []byte) uint32 {
	return NearBlockchainImports.PromiseYieldResume(
		uint64(len(data)),
		uint64(uintptr(unsafe.Pointer(&data[0]))),

		uint64(len(data)),
		uint64(uintptr(unsafe.Pointer(&data[0]))),
	)
}

// Promises API Action

// Promise API Results

// PromiseResultsCount retrieves the count of promise results.
//
// Returns:
// - uint64: The count of promise results.
func PromiseResultsCount() uint64 {
	return NearBlockchainImports.PromiseResultsCount()
}

// PromiseResult retrieves the result of a specified promise.
//
// Parameters:
// - resultIdx: The index of the promise result to retrieve.
//
// Returns:
// - []byte: The result of the specified promise.
// - error: An error if there are no promise results or if the retrieval fails.
func PromiseResult(resultIdx uint64) ([]byte, error) {
	if PromiseResultsCount() == 0 {
		return nil, errors.New(ErrPromiseResult)
	}

	NearBlockchainImports.PromiseResult(resultIdx, AtomicOpRegister)

	value, err := ReadRegisterSafe(AtomicOpRegister)
	if err != nil {
		return nil, errors.New(ErrFailedToReadRegister)
	}

	return value, nil
}

// PromiseReturn returns the result of a specified promise.
//
// Parameters:
// - promiseId: The ID of the promise to return the result for.
func PromiseReturn(promiseId uint64) {
	NearBlockchainImports.PromiseReturn(promiseId)
}

// Promise API Results



==================================================
FILE: env/env_test.go
==================================================

package env

import (
	"encoding/json"
	"testing"

	"github.com/vlmoon99/near-sdk-go/system"
	"github.com/vlmoon99/near-sdk-go/types"
)

func init() {
	SetEnv(system.NewMockSystem())
}

func TestSetEnv(t *testing.T) {
	mockSys := system.NewMockSystem()
	SetEnv(mockSys)

	if NearBlockchainImports != mockSys {
		t.Errorf("expected NearBlockchainImports to be set to mockSys, got %v", NearBlockchainImports)
	}
}

// Registers API

func TestTryMethodIntoRegister(t *testing.T) {
	mockSys := system.NewMockSystem()
	SetEnv(mockSys)

	data := []byte("test data")
	mockSys.Registers[AtomicOpRegister] = data

	method := func(registerId uint64) {
		WriteRegisterSafe(registerId, data)
	}

	result, err := tryMethodIntoRegister(method)
	if err != nil {
		t.Errorf("expected no error, got %v", err)
	}

	if string(result) != string(data) {
		t.Errorf("expected '%s', got '%s'", data, result)
	}
}

func TestMethodIntoRegister(t *testing.T) {
	mockSys := system.NewMockSystem()
	SetEnv(mockSys)

	data := []byte("test data")
	mockSys.Registers[AtomicOpRegister] = data

	method := func(registerId uint64) {
		WriteRegisterSafe(registerId, data)
	}

	result, err := methodIntoRegister(method)
	if err != nil {
		t.Errorf("expected no error, got %v", err)
	}

	if string(result) != string(data) {
		t.Errorf("expected '%s', got '%s'", data, result)
	}
}

func TestReadRegisterSafe(t *testing.T) {
	mockSys := system.NewMockSystem()
	SetEnv(mockSys)

	data := []byte("test data")
	mockSys.Registers[AtomicOpRegister] = data

	result, err := ReadRegisterSafe(AtomicOpRegister)
	if err != nil {
		t.Errorf("expected no error, got %v", err)
	}

	if string(result) != string(data) {
		t.Errorf("expected '%s', got '%s'", data, result)
	}

	result, err = ReadRegisterSafe(1)
	if err == nil {
		t.Errorf("expected error, got nil")
	}

	if len(result) != 0 {
		t.Errorf("expected empty result, got '%s'", result)
	}
}

func TestWriteRegisterSafe(t *testing.T) {
	mockSys := system.NewMockSystem()
	SetEnv(mockSys)

	data := []byte("test data")
	WriteRegisterSafe(1, data)

	if string(mockSys.Registers[1]) != string(data) {
		t.Errorf("expected '%s', got '%s'", data, mockSys.Registers[1])
	}

	WriteRegisterSafe(2, []byte{})
	if _, exists := mockSys.Registers[2]; exists {
		t.Errorf("expected register 2 to be empty")
	}
}

// Registers API

// Storage API
func TestStorageWrite(t *testing.T) {
	initSystem := system.NewMockSystem()
	SetEnv(initSystem)

	key := []byte("testKey")
	value := []byte("testValue")

	success, err := StorageWrite(key, value)
	if !success || err != nil {
		t.Errorf("expected successful write, got error: %v", err)
	}

	if string(initSystem.Storage["testKey"]) != "testValue" {
		t.Errorf("expected value 'testValue', got '%s'", string(initSystem.Storage["testKey"]))
	}
}

func TestStorageRead(t *testing.T) {
	initSystem := system.NewMockSystem()
	SetEnv(initSystem)

	key := []byte("testKey")
	expectedValue := []byte("testValue")
	initSystem.Storage[string(key)] = expectedValue

	value, err := StorageRead(key)
	if err != nil {
		t.Errorf("expected successful read, got error: %v", err)
	}

	if string(value) != string(expectedValue) {
		t.Errorf("expected value '%s', got '%s'", string(expectedValue), string(value))
	}
}

func TestStorageRemove(t *testing.T) {
	initSystem := system.NewMockSystem()
	SetEnv(initSystem)

	key := []byte("testKey")
	value := []byte("testValue")
	initSystem.Storage[string(key)] = value

	success, err := StorageRemove(key)
	if !success || err != nil {
		t.Errorf("expected successful remove, got error: %v", err)
	}

	if _, exists := initSystem.Storage[string(key)]; exists {
		t.Errorf("expected key to be removed, but it still exists")
	}
}

func TestStorageHasKey(t *testing.T) {
	initSystem := system.NewMockSystem()
	SetEnv(initSystem)

	key := []byte("testKey")
	value := []byte("testValue")
	initSystem.Storage[string(key)] = value

	hasKey, err := StorageHasKey(key)
	if err != nil {
		t.Errorf("expected successful has key check, got error: %v", err)
	}

	if !hasKey {
		t.Errorf("expected key to exist, but it does not")
	}

	nonExistingKey := []byte("nonExistingKey")
	hasKey, err = StorageHasKey(nonExistingKey)
	if err != nil {
		t.Errorf("expected successful has key check, got error: %v", err)
	}

	if hasKey {
		t.Errorf("expected key not to exist, but it does")
	}
}

// Storage API

// Context API
func TestGetCurrentAccountId(t *testing.T) {
	accountId, err := GetCurrentAccountId()
	if err != nil {
		t.Fatalf("GetCurrentAccountId failed: %v", err)
	}

	expected := "currentAccountId.near"
	if accountId != expected {
		t.Fatalf("Expected account ID %s, got %s", expected, accountId)
	}
}

func TestGetSignerAccountID(t *testing.T) {
	accountId, err := GetSignerAccountID()
	if err != nil {
		t.Fatalf("GetSignerAccountID failed: %v", err)
	}

	expected := "signerAccountId.near"
	if accountId != expected {
		t.Fatalf("Expected account ID %s, got %s", expected, accountId)
	}
}

func TestGetSignerAccountPK(t *testing.T) {
	accountPk, err := GetSignerAccountPK()
	if err != nil {
		t.Fatalf("GetSignerAccountPK failed: %v", err)
	}

	expected := "signerAccountPk"
	if string(accountPk) != expected {
		t.Fatalf("Expected account PK %s, got %s", expected, string(accountPk))
	}
}

func TestGetPredecessorAccountID(t *testing.T) {
	accountId, err := GetPredecessorAccountID()
	if err != nil {
		t.Fatalf("GetPredecessorAccountID failed: %v", err)
	}

	expected := "predecessorAccountId.near"
	if accountId != expected {
		t.Fatalf("Expected account ID %s, got %s", expected, accountId)
	}
}

func TestGetCurrentBlockHeight(t *testing.T) {
	blockHeight := GetCurrentBlockHeight()
	expected := system.NewMockSystem().BlockTimestamp()

	if blockHeight != expected {
		t.Fatalf("Expected block height %d, got %d", expected, blockHeight)
	}
}

func TestGetBlockTimeMs(t *testing.T) {
	blockTimeMs := GetBlockTimeMs()
	expected := uint64(system.NewMockSystem().BlockTimestamp() / 1_000_000)

	if blockTimeMs != expected {
		t.Fatalf("Expected block time in ms %d, got %d", expected, blockTimeMs)
	}
}

func TestGetEpochHeight(t *testing.T) {
	epochHeight := GetEpochHeight()
	expected := uint64(system.NewMockSystem().EpochHeight())

	if epochHeight != expected {
		t.Fatalf("Expected epoch height %d, got %d", expected, epochHeight)
	}
}

func TestGetStorageUsage(t *testing.T) {
	storageUsage := GetStorageUsage()
	expected := uint64(system.NewMockSystem().StorageUsage())

	if storageUsage != expected {
		t.Fatalf("Expected storage usage %d, got %d", expected, storageUsage)
	}
}

func TestContractInputRawBytes(t *testing.T) {
	options := types.ContractInputOptions{IsRawBytes: true}
	data, dataType, err := ContractInput(options)
	if err != nil {
		t.Fatalf("ContractInput failed: %v", err)
	}

	expectedData := []byte("Test Input")
	expectedType := "rawBytes"

	if string(data) != string(expectedData) {
		t.Fatalf("Expected data %s, got %s", string(expectedData), string(data))
	}

	if dataType != expectedType {
		t.Fatalf("Expected data type %s, got %s", expectedType, dataType)
	}
}

func TestContractInputJSON(t *testing.T) {
	type TestPayload struct {
		Key1 string `json:"key1"`
		Key2 int    `json:"key2"`
		Key3 bool   `json:"key3"`
	}

	inputData := TestPayload{
		Key1: "value1",
		Key2: 42,
		Key3: true,
	}

	jsonData, err := json.Marshal(inputData)
	if err != nil {
		t.Fatalf("json.Marshal failed: %v", err)
	}

	mockSys, _ := NearBlockchainImports.(*system.MockSystem)
	mockSys.ContractInput = jsonData
	mockSys.Input(1)

	options := types.ContractInputOptions{IsRawBytes: false}
	data, dataType, err := ContractInput(options)
	if err != nil {
		t.Fatalf("ContractInput failed: %v", err)
	}

	var result TestPayload
	if err := json.Unmarshal(data, &result); err != nil {
		t.Fatalf("json.Unmarshal failed: %v", err)
	}

	if result.Key1 != "value1" {
		t.Fatalf("Expected value %s, got %s", "value1", result.Key1)
	}

	if result.Key2 != 42 {
		t.Fatalf("Expected value %d, got %d", 42, result.Key2)
	}

	if result.Key3 != true {
		t.Fatalf("Expected value %v, got %v", true, result.Key3)
	}

	expectedType := "object"
	if dataType != expectedType {
		t.Fatalf("Expected data type %s, got %s", expectedType, dataType)
	}
}

// Context API

// Economics API

func TestGetAccountBalance(t *testing.T) {
	expected := types.Uint128{Hi: 0, Lo: 0}
	balance, err := GetAccountBalance()
	if err != nil {
		t.Fatalf("GetAccountBalance failed: %v", err)
	}

	if balance != expected {
		t.Fatalf("Expected balance %v, got %v", expected, balance)
	}
}

func TestGetAccountLockedBalance(t *testing.T) {
	expected := types.Uint128{Hi: 0, Lo: 0}
	balance, err := GetAccountLockedBalance()
	if err != nil {
		t.Fatalf("GetAccountLockedBalance failed: %v", err)
	}

	if balance != expected {
		t.Fatalf("Expected balance %v, got %v", expected, balance)
	}
}

func TestGetAttachedDeposit(t *testing.T) {
	expected := types.Uint128{Hi: 0, Lo: 0}
	deposit, err := GetAttachedDeposit()
	if err != nil {
		t.Fatalf("GetAttachedDeposit failed: %v", err)
	}

	if deposit != expected {
		t.Fatalf("Expected deposit %v, got %v", expected, deposit)
	}
}

func TestGetPrepaidGas(t *testing.T) {
	expected := types.NearGas{Inner: 5000}
	prepaidGas := GetPrepaidGas()

	if prepaidGas != expected {
		t.Fatalf("Expected prepaid gas %v, got %v", expected, prepaidGas)
	}
}

func TestGetUsedGas(t *testing.T) {
	expected := types.NearGas{Inner: 2500}
	usedGas := GetUsedGas()

	if usedGas != expected {
		t.Fatalf("Expected used gas %v, got %v", expected, usedGas)
	}
}

// Economics API

// Math API

func TestGetRandomSeed(t *testing.T) {
	expected := []byte("randomSeed")
	seed, err := GetRandomSeed()
	if err != nil {
		t.Fatalf("GetRandomSeed failed: %v", err)
	}

	if string(seed) != string(expected) {
		t.Fatalf("Expected %s, got %s", string(expected), string(seed))
	}
}

func TestSha256Hash(t *testing.T) {
	data := []byte("test data")
	expected := []byte("hash")
	hash, err := Sha256Hash(data)
	if err != nil {
		t.Fatalf("Sha256Hash failed: %v", err)
	}

	if string(hash) != string(expected) {
		t.Fatalf("Expected %s, got %s", string(expected), string(hash))
	}
}

func TestKeccak256Hash(t *testing.T) {
	data := []byte("test data")
	expected := []byte("hash")
	hash, err := Keccak256Hash(data)
	if err != nil {
		t.Fatalf("Keccak256Hash failed: %v", err)
	}

	if string(hash) != string(expected) {
		t.Fatalf("Expected %s, got %s", string(expected), string(hash))
	}
}

func TestKeccak512Hash(t *testing.T) {
	data := []byte("test data")
	expected := []byte("hash")
	hash, err := Keccak512Hash(data)
	if err != nil {
		t.Fatalf("Keccak512Hash failed: %v", err)
	}

	if string(hash) != string(expected) {
		t.Fatalf("Expected %s, got %s", string(expected), string(hash))
	}
}

func TestRipemd160Hash(t *testing.T) {
	data := []byte("test data")
	expected := []byte("hash")
	hash, err := Ripemd160Hash(data)
	if err != nil {
		t.Fatalf("Ripemd160Hash failed: %v", err)
	}

	if string(hash) != string(expected) {
		t.Fatalf("Expected %s, got %s", string(expected), string(hash))
	}
}

func TestEcrecoverPubKey(t *testing.T) {
	hash := []byte("test hash")
	signature := []byte("test signature")
	v := byte(1)
	malleabilityFlag := true
	expected := []byte{1, 2, 3, 4}

	mockSys, _ := NearBlockchainImports.(*system.MockSystem)
	mockSys.Registers[AtomicOpRegister] = expected

	pubKey, err := EcrecoverPubKey(hash, signature, v, malleabilityFlag)
	if err != nil {
		t.Fatalf("EcrecoverPubKey failed: %v", err)
	}

	if string(pubKey) != string(expected) {
		t.Fatalf("Expected %s, got %s", string(expected), string(pubKey))
	}
}

func TestEd25519VerifySig(t *testing.T) {
	signature := [64]byte{}
	message := []byte("test message")
	publicKey := [32]byte{}

	result := Ed25519VerifySig(signature, message, publicKey)
	if !result {
		t.Fatalf("Expected true , got false")
	}
}

func TestAltBn128G1MultiExp(t *testing.T) {
	data := []byte{1, 2, 3, 4, 5}
	expected := []byte("simpleMultiexp")
	result, err := AltBn128G1MultiExp(data)
	if err != nil {
		t.Fatalf("AltBn128G1MultiExp failed: %v", err)
	}

	if string(result) != string(expected) {
		t.Fatalf("Expected %s, got %s", string(expected), string(result))
	}
}

func TestAltBn128G1Sum(t *testing.T) {
	data := []byte{1, 2, 3, 4, 5}
	expected := []byte("simpleSum")
	result, err := AltBn128G1Sum(data)
	if err != nil {
		t.Fatalf("AltBn128G1Sum failed: %v", err)
	}

	if string(result) != string(expected) {
		t.Fatalf("Expected %s, got %s", string(expected), string(result))
	}
}

func TestAltBn128PairingCheck(t *testing.T) {
	data := []byte("test data")
	result := AltBn128PairingCheck(data)
	if !result {
		t.Fatalf("Expected true , got false")
	}
}

// Math API

// Validator API

func TestValidatorStakeAmount(t *testing.T) {
	accountID := []byte("validatorAccountId")
	expectedStake := types.Uint128{Hi: 0, Lo: 100000}

	stakeAmount, err := ValidatorStakeAmount(accountID)
	if err != nil {
		t.Fatalf("ValidatorStakeAmount failed: %v", err)
	}

	if stakeAmount != expectedStake {
		t.Fatalf("expected stake %v, got %v", expectedStake, stakeAmount)
	}
}

func TestValidatorStakeAmount_EmptyAccountID(t *testing.T) {
	accountID := []byte("")

	_, err := ValidatorStakeAmount(accountID)
	if err == nil || err.Error() != ErrAccountIDMustNotBeEmpty {
		t.Fatalf("expected error %v, got %v", ErrAccountIDMustNotBeEmpty, err)
	}
}

func TestValidatorTotalStakeAmount(t *testing.T) {
	expectedTotalStake := types.Uint128{Hi: 0, Lo: 100000}

	totalStakeAmount, err := ValidatorTotalStakeAmount()
	if err != nil {
		t.Fatalf("ValidatorTotalStakeAmount failed: %v", err)
	}

	if totalStakeAmount != expectedTotalStake {
		t.Fatalf("expected total stake %v, got %v", expectedTotalStake, totalStakeAmount)
	}
}

// Validator API

// Miscellaneous API

func TestContractValueReturn(t *testing.T) {
	input := []byte("test value")
	mockSys, _ := NearBlockchainImports.(*system.MockSystem)
	ContractValueReturn(input)
	if string(mockSys.Registers[0]) != string(input) {
		t.Fatalf("expected %s, got %s", string(input), string(mockSys.Registers[0]))
	}
}

// Miscellaneous API

// Promises API
func TestPromiseCreate(t *testing.T) {
	accountId := []byte("accountId")
	functionName := []byte("functionName")
	arguments := []byte("arguments")
	amount := types.Uint128{Lo: 0, Hi: 0}
	gas := uint64(5000)

	promiseIndex := PromiseCreate(accountId, functionName, arguments, amount, gas)

	expectedIndex := uint64(0)
	if promiseIndex != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIndex)
	}

	mockSys, ok := NearBlockchainImports.(*system.MockSystem)
	if !ok {
		t.Fatalf("Failed to cast NearBlockchainImports to *system.MockSystem")
	}

	if len(mockSys.Promises) != 1 {
		t.Errorf("expected 1 promise, got %d", len(mockSys.Promises))
	}

	promise := mockSys.Promises[0]
	if string(promise.AccountId) != string(accountId) {
		t.Errorf("expected account id %s, got %s", string(accountId), promise.AccountId)
	}
	if string(promise.FunctionName) != string(functionName) {
		t.Errorf("expected function name %s, got %s", string(functionName), promise.FunctionName)
	}
	if string(promise.Arguments) != string(arguments) {
		t.Errorf("expected arguments %s, got %s", string(arguments), string(promise.Arguments))
	}
	if promise.Amount.Lo != amount.Lo {
		t.Errorf("expected amount %d, got %d", amount.Lo, promise.Amount)
	}
	if promise.Gas != gas {
		t.Errorf("expected gas %d, got %d", gas, promise.Gas)
	}
}

func TestPromiseThen(t *testing.T) {
	accountId := []byte("accountId")
	functionName := []byte("functionName")
	arguments := []byte("arguments")
	amount := types.Uint128{Lo: 0, Hi: 0}
	gas := uint64(5000)

	// Create the first promise
	PromiseCreate(accountId, functionName, arguments, amount, gas)

	promiseIdx := uint64(0)
	promiseIndex := PromiseThen(promiseIdx, accountId, functionName, arguments, amount, gas)

	expectedIndex := uint64(2)
	if promiseIndex != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIndex)
	}

	mockSys, ok := NearBlockchainImports.(*system.MockSystem)
	if !ok {
		t.Fatalf("Failed to cast NearBlockchainImports to *system.MockSystem")
	}

	if len(mockSys.Promises) != 3 {
		t.Errorf("expected 3 promises, got %d", len(mockSys.Promises))
	}

	promise := mockSys.Promises[1]
	if string(promise.AccountId) != string(accountId) {
		t.Errorf("expected account id %s, got %s", string(accountId), promise.AccountId)
	}
	if string(promise.FunctionName) != string(functionName) {
		t.Errorf("expected function name %s, got %s", string(functionName), promise.FunctionName)
	}
	if string(promise.Arguments) != string(arguments) {
		t.Errorf("expected arguments %s, got %s", string(arguments), string(promise.Arguments))
	}
	if promise.Amount.Lo != amount.Lo {
		t.Errorf("expected amount %d, got %d", amount.Lo, promise.Amount)
	}
	if promise.Gas != gas {
		t.Errorf("expected gas %d, got %d", gas, promise.Gas)
	}
}

func TestPromiseAnd(t *testing.T) {
	promiseIndices := []uint64{0, 1}
	promiseIndex := PromiseAnd(promiseIndices)

	expectedIndex := uint64(2)
	if promiseIndex != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIndex)
	}
}

func TestPromiseBatchCreate(t *testing.T) {
	accountId := []byte("accountId")
	promiseIndex := PromiseBatchCreate(accountId)

	expectedIndex := uint64(0)
	if promiseIndex != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIndex)
	}
}

func TestPromiseBatchThen(t *testing.T) {
	accountId := []byte("accountId")
	promiseIdx := uint64(0)
	promiseIndex := PromiseBatchThen(promiseIdx, accountId)

	expectedIndex := uint64(1)
	if promiseIndex != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIndex)
	}
}

// Promises API

// Promises API Action

func TestPromiseBatchActionCreateAccount(t *testing.T) {
	promiseIdx := uint64(0)
	PromiseBatchActionCreateAccount(promiseIdx)
	// Verify actions
}

func TestPromiseBatchActionDeployContract(t *testing.T) {
	promiseIdx := uint64(0)
	contractBytes := []byte("sample contract bytes")
	PromiseBatchActionDeployContract(promiseIdx, contractBytes)
	// Verify actions
}

func TestPromiseBatchActionFunctionCall(t *testing.T) {
	promiseIdx := uint64(0)
	functionName := []byte("TestLogStringUtf8")
	arguments := []byte("{}")
	amount := types.Uint128{Hi: 0, Lo: 0}
	gas := uint64(3000000000)
	PromiseBatchActionFunctionCall(promiseIdx, functionName, arguments, amount, gas)
	// Verify actions
}

func TestPromiseBatchActionFunctionCallWeight(t *testing.T) {
	promiseIdx := uint64(0)
	functionName := []byte("TestLogStringUtf8")
	arguments := []byte("{}")
	amount := types.Uint128{Hi: 0, Lo: 0}
	gas := uint64(3000000000)
	weight := uint64(1)
	PromiseBatchActionFunctionCallWeight(promiseIdx, functionName, arguments, amount, gas, weight)
	// Verify actions
}

func TestPromiseBatchActionTransfer(t *testing.T) {
	promiseIdx := uint64(0)
	amount := types.Uint128{Hi: 0, Lo: 1000}
	PromiseBatchActionTransfer(promiseIdx, amount)
	// Verify actions
}

func TestPromiseBatchActionStake(t *testing.T) {
	promiseIdx := uint64(0)
	amount := types.Uint128{Hi: 0, Lo: 1000}
	publicKey := []byte("sample_public_key")
	PromiseBatchActionStake(promiseIdx, amount, publicKey)
	// Verify actions
}

func TestPromiseBatchActionAddKeyWithFullAccess(t *testing.T) {
	promiseIdx := uint64(0)
	publicKey := []byte("sample_public_key")
	nonce := uint64(0)
	PromiseBatchActionAddKeyWithFullAccess(promiseIdx, publicKey, nonce)
	// Verify actions
}

func TestPromiseBatchActionAddKeyWithFunctionCall(t *testing.T) {
	promiseIdx := uint64(0)
	publicKey := []byte("sample_public_key")
	nonce := uint64(0)
	amount := types.Uint128{Hi: 0, Lo: 1000}
	receiverId := []byte("receiver.near")
	functionName := []byte("TestLogStringUtf8")
	PromiseBatchActionAddKeyWithFunctionCall(promiseIdx, publicKey, nonce, amount, receiverId, functionName)
	// Verify actions
}

func TestPromiseBatchActionDeleteKey(t *testing.T) {
	promiseIdx := uint64(0)
	publicKey := []byte("sample_public_key")
	PromiseBatchActionDeleteKey(promiseIdx, publicKey)
	// Verify actions
}

func TestPromiseBatchActionDeleteAccount(t *testing.T) {
	promiseIdx := uint64(0)
	beneficiaryId := []byte("beneficiary.near")
	PromiseBatchActionDeleteAccount(promiseIdx, beneficiaryId)
	// Verify actions
}

func TestPromiseYieldCreate(t *testing.T) {
	functionName := []byte("TestContractValueReturn")
	arguments := []byte("{}")
	gas := uint64(3000000000)
	gasWeight := uint64(0)
	promiseIdx := PromiseYieldCreate(functionName, arguments, gas, gasWeight)
	expectedIndex := uint64(1)
	if promiseIdx != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIdx)
	}
}

func TestPromiseYieldResume(t *testing.T) {
	data := []byte("sample data")
	payload := []byte("sample payload")
	result := PromiseYieldResume(data, payload)
	expectedResult := uint32(1)
	if result != expectedResult {
		t.Errorf("expected result %d, got %d", expectedResult, result)
	}
}

// Promises API Action

// Promise API Results
func TestPromiseResultsCount(t *testing.T) {
	count := PromiseResultsCount()
	expectedCount := uint64(3)
	if count != expectedCount {
		t.Errorf("expected promise count %d, got %d", expectedCount, count)
	}
}

func TestPromiseResult(t *testing.T) {
	resultIdx := uint64(0)
	_, err := PromiseResult(resultIdx)
	if err != nil {
		t.Fatalf("PromiseResult failed: %v", err)
	}

}

func TestPromiseReturn(t *testing.T) {
	promiseId := uint64(0)
	PromiseReturn(promiseId)
}

// Promise API Results



==================================================
FILE: go.mod
==================================================

module github.com/vlmoon99/near-sdk-go

go 1.25.4

require github.com/mr-tron/base58 v1.2.0 // direct

require github.com/vlmoon99/jsonparser v0.0.1



==================================================
FILE: go.sum
==================================================

github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=
github.com/vlmoon99/jsonparser v0.0.1 h1:vfPID9QY/s9bVsYQ7Sl6EDvPTXIEcGVVpVpnbA2cg8s=
github.com/vlmoon99/jsonparser v0.0.1/go.mod h1:GjBpBdc+tq4LSwtfjSIIO/3qLjCTRORUyZMyI3s8VNY=



==================================================
FILE: main.go
==================================================

// Package main is used as an internal smart contract for testing features during development.
// All completed features must be transferred to the examples/* directory and be structured as separate smart contracts.
package main

import (
	"github.com/vlmoon99/near-sdk-go/env"
)

//go:export InitContract
func InitContract() {
	env.LogString("Init Smart Contract")
	env.ContractValueReturn([]byte("1"))
}



==================================================
FILE: new_collections/collections.go
==================================================

package newcollections



==================================================
FILE: new_collections/collections_test.go
==================================================

package newcollections



==================================================
FILE: promise/promise.go
==================================================

// Package promise provides functions for creating and managing promises.
package promise

import (
	"encoding/json"
	"errors"
	"unsafe"

	"github.com/vlmoon99/near-sdk-go/env"
	"github.com/vlmoon99/near-sdk-go/types"
)

const (
	DefaultGas = 5 * types.ONE_TERA_GAS
	MaxGas     = 300 * types.ONE_TERA_GAS
)

const (
	ErrPromiseFailedPrefix         = "promise failed with status: "
	ErrMarshalingArgsInThen        = "Error marshaling args in Then: "
	ErrGettingCurrentAccountInThen = "Error getting current account in Then: "
	ErrMarshalingArgsInThenCall    = "Error marshaling args in ThenCall: "
	ErrMarshalingArgsInJoin        = "Error marshaling args in Join: "
	ErrGettingCurrentAccountInJoin = "Error getting current account in Join: "
	ErrMarshalingArgsInCall        = "Error marshaling args in FunctionCall: "
	ErrMarshalingArgsInCrossCall   = "Error marshaling args in Call: "
	ErrFailedToGetPromiseResult    = "failed to get promise result at index "
	ErrNoPromiseResults            = "no promise results available"
	ErrPromiseResultNotReady       = "promise result not ready"
	ErrFailedToReadPromiseResult   = "failed to read successful promise result: "
	ErrUnknownPromiseResultStatus  = "unknown promise result status: "
	ErrCallbackOnly                = "this function can only be called as a callback"
	ErrCallbackFromSelfOnly        = "callbacks can only be called by the contract itself"
	ErrRegisterEmpty               = "Register is empty, returning empty byte array"
	ErrStandardRegisterReadFailed  = "Standard register read failed: "
	ErrSuccessfullyReadBytes       = "Successfully read "
	ErrBytesFromRegister           = " bytes from register"
	ErrDirectRegisterReadCompleted = "Direct register read completed for "
	ErrFailedToCreateBuffer        = "failed to create buffer for register read"
	ErrRegisterLength              = "Register "
	ErrLength                      = " length: "
)

type BatchAction string

const (
	CreateAccountAction      BatchAction = "create_account"
	DeployContractAction     BatchAction = "deploy_contract"
	FunctionCallAction       BatchAction = "function_call"
	TransferAction           BatchAction = "transfer"
	StakeAction              BatchAction = "stake"
	AddKeyFullAccessAction   BatchAction = "add_key_full_access"
	AddKeyFunctionCallAction BatchAction = "add_key_function_call"
	DeleteKeyAction          BatchAction = "delete_key"
	DeleteAccountAction      BatchAction = "delete_account"
)

type PromiseResult struct {
	StatusCode int
	Data       []byte
	Success    bool
}

func NewPromiseResult(statusCode int, data []byte) PromiseResult {
	return PromiseResult{
		StatusCode: statusCode,
		Data:       data,
		Success:    statusCode == 1,
	}
}

func (pr PromiseResult) Unwrap() ([]byte, error) {
	if !pr.Success {
		statusName := getStatusName(pr.StatusCode)
		return nil, errors.New(ErrPromiseFailedPrefix + statusName)
	}
	return pr.Data, nil
}

func (pr PromiseResult) UnwrapOr(defaultValue []byte) []byte {
	if pr.Success {
		return pr.Data
	}
	return defaultValue
}

func getStatusName(statusCode int) string {
	switch statusCode {
	case 0:
		return "NotReady"
	case 1:
		return "Successful"
	case 2:
		return "Failed"
	default:
		return "Unknown"
	}
}

type Promise struct {
	promiseID uint64
	gas       uint64
	deposit   types.Uint128
}

func NewPromise(promiseID uint64) *Promise {
	return &Promise{
		promiseID: promiseID,
		gas:       DefaultGas,
		deposit:   types.Uint128{Hi: 0, Lo: 0},
	}
}

func CreateBatch(accountID string) *PromiseBatch {
	promiseID := env.PromiseBatchCreate([]byte(accountID))
	return NewPromiseBatch(promiseID)
}

func (p *Promise) Gas(amount uint64) *Promise {
	return &Promise{
		promiseID: p.promiseID,
		gas:       amount,
		deposit:   p.deposit,
	}
}

func (p *Promise) Deposit(amount types.Uint128) *Promise {
	return &Promise{
		promiseID: p.promiseID,
		gas:       p.gas,
		deposit:   amount,
	}
}

func (p *Promise) DepositYocto(amount uint64) *Promise {
	return p.Deposit(types.U64ToUint128(amount))
}

func (p *Promise) Then(method string, args interface{}) *Promise {
	argsBytes, err := json.Marshal(args)
	if err != nil {
		env.LogString(ErrMarshalingArgsInThen + err.Error())
		return p
	}

	currentAccount, err := env.GetCurrentAccountId()
	if err != nil {
		env.LogString(ErrGettingCurrentAccountInThen + err.Error())
		return p
	}

	promiseID := env.PromiseThen(
		p.promiseID,
		[]byte(currentAccount),
		[]byte(method),
		argsBytes,
		types.Uint128{Hi: 0, Lo: 0},
		p.gas,
	)

	return NewPromise(promiseID)
}

func (p *Promise) ThenCall(contractID, method string, args interface{}) *Promise {
	argsBytes, err := json.Marshal(args)
	if err != nil {
		env.LogString(ErrMarshalingArgsInThenCall + err.Error())
		return p
	}

	promiseID := env.PromiseThen(
		p.promiseID,
		[]byte(contractID),
		[]byte(method),
		argsBytes,
		p.deposit,
		p.gas,
	)

	return NewPromise(promiseID)
}

func (p *Promise) ThenBatch(accountID string) *PromiseBatch {
	promiseID := env.PromiseBatchThen(p.promiseID, []byte(accountID))
	return NewPromiseBatch(promiseID).Gas(p.gas)
}

func (p *Promise) Join(otherPromises []*Promise, callback string, args interface{}) *Promise {
	promiseIDs := make([]uint64, len(otherPromises)+1)
	promiseIDs[0] = p.promiseID
	for i, promise := range otherPromises {
		promiseIDs[i+1] = promise.promiseID
	}

	combinedPromise := env.PromiseAnd(promiseIDs)

	argsBytes, err := json.Marshal(args)
	if err != nil {
		env.LogString(ErrMarshalingArgsInJoin + err.Error())
		return p
	}

	currentAccount, err := env.GetCurrentAccountId()
	if err != nil {
		env.LogString(ErrGettingCurrentAccountInJoin + err.Error())
		return p
	}

	promiseID := env.PromiseThen(
		combinedPromise,
		[]byte(currentAccount),
		[]byte(callback),
		argsBytes,
		types.Uint128{Hi: 0, Lo: 0},
		p.gas,
	)

	return NewPromise(promiseID)
}

func All(promises []*Promise) uint64 {
	promiseIDs := make([]uint64, len(promises))
	for i, promise := range promises {
		promiseIDs[i] = promise.promiseID
	}
	return env.PromiseAnd(promiseIDs)
}

func (p *Promise) Value() {
	env.PromiseReturn(p.promiseID)
}

type PromiseBatch struct {
	promiseID uint64
	gas       uint64
}

func NewPromiseBatch(promiseID uint64) *PromiseBatch {
	return &PromiseBatch{
		promiseID: promiseID,
		gas:       DefaultGas,
	}
}

func (pb *PromiseBatch) Gas(amount uint64) *PromiseBatch {
	return &PromiseBatch{
		promiseID: pb.promiseID,
		gas:       amount,
	}
}

func (pb *PromiseBatch) CreateAccount() *PromiseBatch {
	env.PromiseBatchActionCreateAccount(pb.promiseID)
	return pb
}

func (pb *PromiseBatch) DeployContract(code []byte) *PromiseBatch {
	env.PromiseBatchActionDeployContract(pb.promiseID, code)
	return pb
}

func (pb *PromiseBatch) FunctionCall(method string, args interface{}, amount types.Uint128, gas uint64) *PromiseBatch {
	if gas == 0 {
		gas = pb.gas
	}

	argsBytes, err := json.Marshal(args)
	if err != nil {
		env.LogString(ErrMarshalingArgsInCall + err.Error())
		return pb
	}

	env.PromiseBatchActionFunctionCall(
		pb.promiseID,
		[]byte(method),
		argsBytes,
		amount,
		gas,
	)
	return pb
}

func (pb *PromiseBatch) FunctionCallSimple(method string, args interface{}) *PromiseBatch {
	return pb.FunctionCall(method, args, types.Uint128{Hi: 0, Lo: 0}, pb.gas)
}

func (pb *PromiseBatch) Transfer(amount types.Uint128) *PromiseBatch {
	env.PromiseBatchActionTransfer(pb.promiseID, amount)
	return pb
}

func (pb *PromiseBatch) TransferYocto(amount uint64) *PromiseBatch {
	return pb.Transfer(types.U64ToUint128(amount))
}

func (pb *PromiseBatch) Stake(amount types.Uint128, publicKey []byte) *PromiseBatch {
	env.PromiseBatchActionStake(pb.promiseID, amount, publicKey)
	return pb
}

func (pb *PromiseBatch) AddFullAccessKey(publicKey []byte, nonce uint64) *PromiseBatch {
	env.PromiseBatchActionAddKeyWithFullAccess(pb.promiseID, publicKey, nonce)
	return pb
}

func (pb *PromiseBatch) AddAccessKey(publicKey []byte, allowance types.Uint128, receiverID string, methodNames []string, nonce uint64) *PromiseBatch {
	methodsStr := ""
	for i, method := range methodNames {
		if i > 0 {
			methodsStr += ","
		}
		methodsStr += method
	}

	env.PromiseBatchActionAddKeyWithFunctionCall(
		pb.promiseID,
		publicKey,
		nonce,
		allowance,
		[]byte(receiverID),
		[]byte(methodsStr),
	)
	return pb
}

func (pb *PromiseBatch) DeleteKey(publicKey []byte) *PromiseBatch {
	env.PromiseBatchActionDeleteKey(pb.promiseID, publicKey)
	return pb
}

func (pb *PromiseBatch) DeleteAccount(beneficiaryID string) *PromiseBatch {
	env.PromiseBatchActionDeleteAccount(pb.promiseID, []byte(beneficiaryID))
	return pb
}

func (pb *PromiseBatch) Then(accountID string) *PromiseBatch {
	promiseID := env.PromiseBatchThen(pb.promiseID, []byte(accountID))
	return NewPromiseBatch(promiseID).Gas(pb.gas)
}

func (pb *PromiseBatch) Value() {
	env.PromiseReturn(pb.promiseID)
}

type CrossContract struct {
	accountID string
	gas       uint64
	deposit   types.Uint128
}

func NewCrossContract(accountID string) *CrossContract {
	return &CrossContract{
		accountID: accountID,
		gas:       DefaultGas,
		deposit:   types.Uint128{Hi: 0, Lo: 0},
	}
}

func (cc *CrossContract) Gas(amount uint64) *CrossContract {
	return &CrossContract{
		accountID: cc.accountID,
		gas:       amount,
		deposit:   cc.deposit,
	}
}

func (cc *CrossContract) Deposit(amount types.Uint128) *CrossContract {
	return &CrossContract{
		accountID: cc.accountID,
		gas:       cc.gas,
		deposit:   amount,
	}
}

func (cc *CrossContract) DepositYocto(amount uint64) *CrossContract {
	return cc.Deposit(types.U64ToUint128(amount))
}

func (cc *CrossContract) Call(method string, args interface{}) *Promise {

	argsBytes, err := json.Marshal(args)

	if err != nil {
		env.LogString(ErrMarshalingArgsInCall + err.Error())
		return NewPromise(0)
	}

	promiseID := env.PromiseCreate(
		[]byte(cc.accountID),
		[]byte(method),
		argsBytes,
		cc.deposit,
		cc.gas,
	)

	return NewPromise(promiseID).Gas(cc.gas)
}

func (cc *CrossContract) Batch() *PromiseBatch {
	promiseID := env.PromiseBatchCreate([]byte(cc.accountID))
	return NewPromiseBatch(promiseID).Gas(cc.gas)
}

func GetPromiseResult(index uint64) (PromiseResult, error) {
	if env.PromiseResultsCount() == 0 {
		return PromiseResult{}, errors.New(ErrNoPromiseResults)
	}

	data, err := env.PromiseResult(index)
	if err != nil {
		if err.Error() == "(PROMISE_ERROR): promise execution failed with data" {
			return NewPromiseResult(2, data), nil
		} else if err.Error() == "(PROMISE_ERROR): promise execution failed" {
			return NewPromiseResult(2, []byte{}), nil
		}
		return PromiseResult{}, err
	}

	return NewPromiseResult(1, data), nil
}

func GetPromiseResultSafe(index uint64) (PromiseResult, error) {
	count := env.PromiseResultsCount()
	if count == 0 {
		return PromiseResult{}, errors.New(ErrNoPromiseResults)
	}

	if index >= count {
		return PromiseResult{}, errors.New(ErrFailedToGetPromiseResult + types.IntToString(int(index)))
	}

	status, data, err := GetPromiseResultWithStatus(index)
	if err != nil {
		return PromiseResult{}, err
	}

	return NewPromiseResult(int(status), data), nil
}

func GetPromiseResultWithStatus(index uint64) (uint64, []byte, error) {
	status := env.NearBlockchainImports.PromiseResult(index, env.AtomicOpRegister)

	switch status {
	case 0:
		return status, nil, errors.New(ErrPromiseResultNotReady)
	case 1:
		data, err := ReadRegisterSafeWithFallback(env.AtomicOpRegister)
		if err != nil {
			return status, nil, errors.New(ErrFailedToReadPromiseResult + err.Error())
		}
		return status, data, nil
	case 2:
		data, err := ReadRegisterSafeWithFallback(env.AtomicOpRegister)
		if err != nil {
			return status, []byte{}, nil
		}
		return status, data, nil
	default:
		return status, nil, errors.New(ErrUnknownPromiseResultStatus + types.IntToString(int(status)))
	}
}

func GetAllPromiseResults() ([]PromiseResult, error) {
	count := env.PromiseResultsCount()
	if count == 0 {
		return nil, errors.New(ErrNoPromiseResults)
	}

	results := make([]PromiseResult, count)
	for i := uint64(0); i < count; i++ {
		result, err := GetPromiseResult(i)
		if err != nil {
			return nil, errors.New(ErrFailedToGetPromiseResult + types.IntToString(int(i)) + ": " + err.Error())
		}
		results[i] = result
	}

	return results, nil
}

func IsCallback() bool {
	return env.PromiseResultsCount() > 0
}

func IsCallbackFromSelf() bool {
	if !IsCallback() {
		return false
	}

	predecessor, err := env.GetPredecessorAccountID()
	if err != nil {
		return false
	}

	current, err := env.GetCurrentAccountId()
	if err != nil {
		return false
	}

	return predecessor == current
}

func CallbackGuard() error {
	if !IsCallback() {
		return errors.New(ErrCallbackOnly)
	}

	if !IsCallbackFromSelf() {
		return errors.New(ErrCallbackFromSelfOnly)
	}

	return nil
}

func ReadRegisterSafeWithFallback(registerId uint64) ([]byte, error) {
	length := env.NearBlockchainImports.RegisterLen(registerId)
	env.LogString(ErrRegisterLength + types.IntToString(int(registerId)) + ErrLength + types.IntToString(int(length)))

	if length == 0 {
		env.LogString(ErrRegisterEmpty)
		return []byte{}, nil
	}

	data, err := env.ReadRegisterSafe(registerId)
	if err != nil {
		env.LogString(ErrStandardRegisterReadFailed + err.Error())

		return ReadRegisterDirect(registerId, length)
	}

	env.LogString(ErrSuccessfullyReadBytes + types.IntToString(len(data)) + ErrBytesFromRegister)
	return data, nil
}

func ReadRegisterDirect(registerId uint64, length uint64) ([]byte, error) {
	if length == 0 {
		return []byte{}, nil
	}

	buffer := make([]byte, length)
	if len(buffer) > 0 {
		ptr := uint64(uintptr(unsafe.Pointer(&buffer[0])))
		env.NearBlockchainImports.ReadRegister(registerId, ptr)
		env.LogString(ErrDirectRegisterReadCompleted + types.IntToString(int(length)) + ErrBytesFromRegister)
		return buffer, nil
	}

	return []byte{}, errors.New(ErrFailedToCreateBuffer)
}



==================================================
FILE: promise/promise_test.go
==================================================

package promise

import (
	"testing"

	"github.com/vlmoon99/near-sdk-go/env"
	"github.com/vlmoon99/near-sdk-go/system"
	"github.com/vlmoon99/near-sdk-go/types"
)

func init() {
	systemMock := system.NewMockSystem()
	env.SetEnv(systemMock)
}

func TestNewPromise(t *testing.T) {
	promiseID := uint64(123)
	promise := NewPromise(promiseID)

	if promise.promiseID != promiseID {
		t.Errorf("NewPromise() promiseID = %v, want %v", promise.promiseID, promiseID)
	}
	if promise.gas != DefaultGas {
		t.Errorf("NewPromise() gas = %v, want %v", promise.gas, DefaultGas)
	}
	if promise.deposit != (types.Uint128{Hi: 0, Lo: 0}) {
		t.Errorf("NewPromise() deposit = %v, want %v", promise.deposit, types.Uint128{Hi: 0, Lo: 0})
	}
}

func TestPromise_Gas(t *testing.T) {
	promise := NewPromise(123)
	gas := uint64(1000)
	newPromise := promise.Gas(gas)

	if newPromise.gas != gas {
		t.Errorf("Gas() = %v, want %v", newPromise.gas, gas)
	}
	if newPromise.promiseID != promise.promiseID {
		t.Errorf("Gas() promiseID = %v, want %v", newPromise.promiseID, promise.promiseID)
	}
}

func TestPromise_Deposit(t *testing.T) {
	promise := NewPromise(123)
	deposit := types.Uint128{Hi: 1, Lo: 2}
	newPromise := promise.Deposit(deposit)

	if newPromise.deposit != deposit {
		t.Errorf("Deposit() = %v, want %v", newPromise.deposit, deposit)
	}
	if newPromise.promiseID != promise.promiseID {
		t.Errorf("Deposit() promiseID = %v, want %v", newPromise.promiseID, promise.promiseID)
	}
}

func TestPromise_DepositYocto(t *testing.T) {
	promise := NewPromise(123)
	amount := uint64(1000)
	newPromise := promise.DepositYocto(amount)

	expected := types.U64ToUint128(amount)
	if newPromise.deposit != expected {
		t.Errorf("DepositYocto() = %v, want %v", newPromise.deposit, expected)
	}
}

func TestNewPromiseBatch(t *testing.T) {
	promiseID := uint64(123)
	batch := NewPromiseBatch(promiseID)

	if batch.promiseID != promiseID {
		t.Errorf("NewPromiseBatch() promiseID = %v, want %v", batch.promiseID, promiseID)
	}
	if batch.gas != DefaultGas {
		t.Errorf("NewPromiseBatch() gas = %v, want %v", batch.gas, DefaultGas)
	}
}

func TestPromiseBatch_Gas(t *testing.T) {
	batch := NewPromiseBatch(123)
	gas := uint64(1000)
	newBatch := batch.Gas(gas)

	if newBatch.gas != gas {
		t.Errorf("Gas() = %v, want %v", newBatch.gas, gas)
	}
	if newBatch.promiseID != batch.promiseID {
		t.Errorf("Gas() promiseID = %v, want %v", newBatch.promiseID, batch.promiseID)
	}
}

func TestNewCrossContract(t *testing.T) {
	accountID := "test.account"
	contract := NewCrossContract(accountID)

	if contract.accountID != accountID {
		t.Errorf("NewCrossContract() accountID = %v, want %v", contract.accountID, accountID)
	}
	if contract.gas != DefaultGas {
		t.Errorf("NewCrossContract() gas = %v, want %v", contract.gas, DefaultGas)
	}
	if contract.deposit != (types.Uint128{Hi: 0, Lo: 0}) {
		t.Errorf("NewCrossContract() deposit = %v, want %v", contract.deposit, types.Uint128{Hi: 0, Lo: 0})
	}
}

func TestCrossContract_Gas(t *testing.T) {
	contract := NewCrossContract("test.account")
	gas := uint64(1000)
	newContract := contract.Gas(gas)

	if newContract.gas != gas {
		t.Errorf("Gas() = %v, want %v", newContract.gas, gas)
	}
	if newContract.accountID != contract.accountID {
		t.Errorf("Gas() accountID = %v, want %v", newContract.accountID, contract.accountID)
	}
}

func TestCrossContract_Deposit(t *testing.T) {
	contract := NewCrossContract("test.account")
	deposit := types.Uint128{Hi: 1, Lo: 2}
	newContract := contract.Deposit(deposit)

	if newContract.deposit != deposit {
		t.Errorf("Deposit() = %v, want %v", newContract.deposit, deposit)
	}
	if newContract.accountID != contract.accountID {
		t.Errorf("Deposit() accountID = %v, want %v", newContract.accountID, contract.accountID)
	}
}

func TestCrossContract_DepositYocto(t *testing.T) {
	contract := NewCrossContract("test.account")
	amount := uint64(1000)
	newContract := contract.DepositYocto(amount)

	expected := types.U64ToUint128(amount)
	if newContract.deposit != expected {
		t.Errorf("DepositYocto() = %v, want %v", newContract.deposit, expected)
	}
}

func TestPromiseResult_Unwrap(t *testing.T) {
	tests := []struct {
		name        string
		result      PromiseResult
		wantData    []byte
		wantErr     bool
		errContains string
	}{
		{
			name:        "Successful result",
			result:      NewPromiseResult(1, []byte("success")),
			wantData:    []byte("success"),
			wantErr:     false,
			errContains: "",
		},
		{
			name:        "Failed result",
			result:      NewPromiseResult(2, []byte("error")),
			wantData:    nil,
			wantErr:     true,
			errContains: "promise failed with status: Failed",
		},
		{
			name:        "Not ready result",
			result:      NewPromiseResult(0, nil),
			wantData:    nil,
			wantErr:     true,
			errContains: "promise failed with status: NotReady",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			data, err := tt.result.Unwrap()
			if (err != nil) != tt.wantErr {
				t.Errorf("PromiseResult.Unwrap() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.wantErr && err.Error() != tt.errContains {
				t.Errorf("PromiseResult.Unwrap() error = %v, want %v", err, tt.errContains)
			}
			if !tt.wantErr && string(data) != string(tt.wantData) {
				t.Errorf("PromiseResult.Unwrap() = %v, want %v", data, tt.wantData)
			}
		})
	}
}

func TestPromiseResult_UnwrapOr(t *testing.T) {
	tests := []struct {
		name           string
		result         PromiseResult
		defaultValue   []byte
		expectedResult []byte
	}{
		{
			name:           "Successful result",
			result:         NewPromiseResult(1, []byte("success")),
			defaultValue:   []byte("default"),
			expectedResult: []byte("success"),
		},
		{
			name:           "Failed result",
			result:         NewPromiseResult(2, []byte("error")),
			defaultValue:   []byte("default"),
			expectedResult: []byte("default"),
		},
		{
			name:           "Not ready result",
			result:         NewPromiseResult(0, nil),
			defaultValue:   []byte("default"),
			expectedResult: []byte("default"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tt.result.UnwrapOr(tt.defaultValue)
			if string(result) != string(tt.expectedResult) {
				t.Errorf("PromiseResult.UnwrapOr() = %v, want %v", result, tt.expectedResult)
			}
		})
	}
}

func TestPromiseResult_UnwrapToParser(t *testing.T) {
	tests := []struct {
		name        string
		result      PromiseResult
		wantErr     bool
		errContains string
	}{
		{
			name:        "Successful result",
			result:      NewPromiseResult(1, []byte(`{"key":"value"}`)),
			wantErr:     false,
			errContains: "",
		},
		{
			name:        "Failed result",
			result:      NewPromiseResult(2, []byte("error")),
			wantErr:     true,
			errContains: "promise failed with status: Failed",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			data, err := tt.result.Unwrap()
			if (err != nil) != tt.wantErr {
				t.Errorf("PromiseResult.UnwrapToParser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if tt.wantErr && err.Error() != tt.errContains {
				t.Errorf("PromiseResult.UnwrapToParser() error = %v, want %v", err, tt.errContains)
			}
			if !tt.wantErr && data == nil {
				t.Error("PromiseResult.UnwrapToParser() data is nil")
			}
		})
	}
}



==================================================
FILE: system/system.go
==================================================

// Package "system" provides system bindings to interact with the NEAR Blockchain environment.
// These bindings facilitate the creation of smart contracts and provide all necessary functions for working with them.
// The implementation of these system methods can be found in the `sdk` package, specifically in the `env.go` file.
// It is not recommended to use this package directly unless you fully understand what you are doing.
//
// system_mock.go - represents mocks for unit tests
//
// system_near.go - represents NEAR System methods which the blockchain will provide inside the WASM environment.
package system

type System interface {
	//Registers API
	ReadRegister(registerId, ptr uint64)
	RegisterLen(registerId uint64) uint64
	WriteRegister(registerId, dataLen, dataPtr uint64)
	//Registers API

	// Storage API
	StorageWrite(keyLen, keyPtr, valueLen, valuePtr, registerId uint64) uint64
	StorageRead(keyLen uint64, keyPtr uint64, registerId uint64) uint64
	StorageRemove(keyLen, keyPtr, registerId uint64) uint64
	StorageHasKey(keyLen, keyPtr uint64) uint64
	// Storage API

	//Context API
	CurrentAccountId(registerId uint64)
	SignerAccountId(registerId uint64)
	SignerAccountPk(registerId uint64)
	PredecessorAccountId(registerId uint64)
	Input(registerId uint64)
	BlockIndex() uint64
	BlockTimestamp() uint64
	EpochHeight() uint64
	StorageUsage() uint64
	//Context API

	// Economics API
	AccountBalance(balancePtr uint64)
	AccountLockedBalance(balancePtr uint64)
	AttachedDeposit(balancePtr uint64)
	PrepaidGas() uint64
	UsedGas() uint64
	// Economics API

	// Math API
	RandomSeed(registerId uint64)
	Sha256(valueLen, valuePtr, registerId uint64)
	Keccak256(valueLen, valuePtr, registerId uint64)
	Keccak512(valueLen, valuePtr, registerId uint64)
	Ripemd160(valueLen, valuePtr, registerId uint64)
	Ecrecover(hashLen, hashPtr, sigLen, sigPtr, v, malleabilityFlag, registerId uint64) uint64
	Ed25519Verify(sigLen, sigPtr, msgLen, msgPtr, pubKeyLen, pubKeyPtr uint64) uint64
	AltBn128G1Multiexp(valueLen, valuePtr, registerId uint64)
	AltBn128G1SumSystem(valueLen, valuePtr, registerId uint64)
	AltBn128PairingCheckSystem(valueLen, valuePtr uint64) uint64
	// Math API

	// Validator API
	ValidatorStake(accountIdLen, accountIdPtr, stakePtr uint64)
	ValidatorTotalStake(stakePtr uint64)
	// Validator API

	// Miscellaneous API
	ValueReturn(valueLen, valuePtr uint64)
	PanicUtf8(len, ptr uint64)
	LogUtf8(len, ptr uint64)
	LogUtf16(len, ptr uint64)
	// Abort(msgPtr, filenamePtr, line, col uint32)
	// Panic()
	// Miscellaneous API

	// Promises API
	PromiseCreate(accountIdLen, accountIdPtr, functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, amountPtr, gas uint64) uint64
	PromiseThen(promiseIndex, accountIdLen, accountIdPtr, functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, amountPtr, gas uint64) uint64
	PromiseAnd(promiseIdxPtr, promiseIdxCount uint64) uint64
	PromiseBatchCreate(accountIdLen, accountIdPtr uint64) uint64
	PromiseBatchThen(promiseIndex, accountIdLen, accountIdPtr uint64) uint64
	// Promises API

	// Promise API Actions
	PromiseBatchActionCreateAccount(promiseIndex uint64)
	PromiseBatchActionDeployContract(promiseIndex, codeLen, codePtr uint64)
	PromiseBatchActionFunctionCall(promiseIndex, functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, amountPtr, gas uint64)
	PromiseBatchActionFunctionCallWeight(promise_index, function_name_len, function_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas, weight uint64)
	PromiseBatchActionTransfer(promiseIndex, amountPtr uint64)
	PromiseBatchActionStake(promiseIndex, amountPtr, publicKeyLen, publicKeyPtr uint64)
	PromiseBatchActionAddKeyWithFullAccess(promiseIndex, publicKeyLen, publicKeyPtr, nonce uint64)
	PromiseBatchActionAddKeyWithFunctionCall(promiseIndex, publicKeyLen, publicKeyPtr, nonce, allowancePtr, receiverIdLen, receiverIdPtr, functionNamesLen, functionNamesPtr uint64)
	PromiseBatchActionDeleteKey(promiseIndex, publicKeyLen, publicKeyPtr uint64)
	PromiseBatchActionDeleteAccount(promiseIndex, beneficiaryIdLen, beneficiaryIdPtr uint64)
	PromiseYieldCreate(functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, gas, gasWeight, registerId uint64) uint64
	PromiseYieldResume(dataIdLen, dataIdPtr, payloadLen, payloadPtr uint64) uint32
	// Promise API Actions

	// Promise API Results
	PromiseResultsCount() uint64
	PromiseResult(resultIdx uint64, registerId uint64) uint64
	PromiseReturn(promiseId uint64)
	// Promise API Results

}



==================================================
FILE: system/system_mock.go
==================================================

package system

// For some env limitation reason we can't use crypto/* or golang.org/x/crypto/* packages
import (
	"encoding/binary"
	"unsafe"

	"github.com/vlmoon99/near-sdk-go/types"
)

type MockPromise struct {
	AccountId    string
	FunctionName string
	Arguments    []byte
	Amount       types.Uint128
	Gas          uint64
	PromiseIndex uint64
}

// Test Mock impl of the System interface
type MockSystem struct {
	Promises                []MockPromise
	Registers               map[uint64][]byte
	Storage                 map[string][]byte
	CurrentAccountIdSys     string
	SignerAccountIdSys      string
	SignerAccountPkSys      []byte
	PredecessorAccountIdSys string
	ContractInput           []byte
	BlockIndexSys           uint64
	BlockTimestampSys       uint64
	EpochHeightSys          uint64
	StorageUsageSys         uint64
	AccountBalanceSys       types.Uint128
	AccountLockedBalanceSys types.Uint128
	AttachedDepositSys      types.Uint128
	PrepaidGasSys           uint64
	UsedGasSys              uint64
}

func NewMockSystem() *MockSystem {
	return &MockSystem{
		Registers:               make(map[uint64][]byte),
		Storage:                 make(map[string][]byte),
		CurrentAccountIdSys:     "currentAccountId.near",
		SignerAccountIdSys:      "signerAccountId.near",
		SignerAccountPkSys:      []byte("signerAccountPk"),
		PredecessorAccountIdSys: "predecessorAccountId.near",
		ContractInput:           []byte("Test Input"),
		BlockIndexSys:           1,
		BlockTimestampSys:       uint64(1739394085901002712),
		EpochHeightSys:          1,
		StorageUsageSys:         0,
		AccountBalanceSys:       types.Uint128{Hi: 0, Lo: 0},
		AccountLockedBalanceSys: types.Uint128{Hi: 0, Lo: 0},
		AttachedDepositSys:      types.Uint128{Hi: 0, Lo: 0},
		PrepaidGasSys:           5000,
		UsedGasSys:              2500,
	}
}

// Registers API

func (m *MockSystem) WriteRegister(registerId, dataLen, dataPtr uint64) {
	dataSlice := make([]byte, dataLen)
	copy(dataSlice, unsafe.Slice((*byte)(unsafe.Pointer(uintptr(dataPtr))), dataLen))

	m.Registers[registerId] = dataSlice
}

func (m *MockSystem) ReadRegister(registerId, ptr uint64) {
	if data, exists := m.Registers[registerId]; exists {
		copy(unsafe.Slice((*byte)(unsafe.Pointer(uintptr(ptr))), len(data)), data)
	}
}

func (m *MockSystem) RegisterLen(registerId uint64) uint64 {
	if data, exists := m.Registers[registerId]; exists {
		return uint64(len(data))
	}
	return 0
}

// Registers API

// Storage API
func (m *MockSystem) StorageWrite(keyLen, keyPtr, valueLen, valuePtr, registerId uint64) uint64 {
	key := unsafe.Slice((*byte)(unsafe.Pointer(uintptr(keyPtr))), keyLen)
	value := unsafe.Slice((*byte)(unsafe.Pointer(uintptr(valuePtr))), valueLen)
	keyStr := string(key)

	m.Storage[keyStr] = make([]byte, valueLen)
	copy(m.Storage[keyStr], value)

	if registerId != 0 {
		m.WriteRegister(registerId, valueLen, valuePtr)
	}
	return 1
}

func (m *MockSystem) StorageRead(keyLen, keyPtr, registerId uint64) uint64 {
	key := unsafe.Slice((*byte)(unsafe.Pointer(uintptr(keyPtr))), keyLen)
	keyStr := string(key)

	if value, exists := m.Storage[keyStr]; exists {
		if registerId != 0 {
			valueCopy := make([]byte, len(value))
			copy(valueCopy, value)
			m.WriteRegister(registerId, uint64(len(valueCopy)), uint64(uintptr(unsafe.Pointer(&valueCopy[0]))))
		}
		return 1
	}
	return 0
}

func (m *MockSystem) StorageRemove(keyLen, keyPtr, registerId uint64) uint64 {
	key := unsafe.Slice((*byte)(unsafe.Pointer(uintptr(keyPtr))), keyLen)
	keyStr := string(key)

	if value, exists := m.Storage[keyStr]; exists {
		if registerId != 0 {
			// Create a copy of the value to avoid pointer issues
			valueCopy := make([]byte, len(value))
			copy(valueCopy, value)
			m.WriteRegister(registerId, uint64(len(valueCopy)), uint64(uintptr(unsafe.Pointer(&valueCopy[0]))))
		}
		delete(m.Storage, keyStr)
		return 1
	}
	return 0
}

func (m *MockSystem) StorageHasKey(keyLen, keyPtr uint64) uint64 {
	key := unsafe.Slice((*byte)(unsafe.Pointer(uintptr(keyPtr))), keyLen)
	keyStr := string(key)

	if _, exists := m.Storage[keyStr]; exists {
		return 1
	}
	return 0
}

// Storage API

// Context API
func (m *MockSystem) CurrentAccountId(registerId uint64) {
	data := []byte(m.CurrentAccountIdSys)
	m.WriteRegister(registerId, uint64(len(data)), uint64(uintptr(unsafe.Pointer(&data[0]))))
}

func (m *MockSystem) SignerAccountId(registerId uint64) {
	data := []byte(m.SignerAccountIdSys)
	m.WriteRegister(registerId, uint64(len(data)), uint64(uintptr(unsafe.Pointer(&data[0]))))
}

func (m *MockSystem) SignerAccountPk(registerId uint64) {
	data := m.SignerAccountPkSys
	m.WriteRegister(registerId, uint64(len(data)), uint64(uintptr(unsafe.Pointer(&data[0]))))
}

func (m *MockSystem) PredecessorAccountId(registerId uint64) {
	data := []byte(m.PredecessorAccountIdSys)
	m.WriteRegister(registerId, uint64(len(data)), uint64(uintptr(unsafe.Pointer(&data[0]))))
}

func (m *MockSystem) Input(registerId uint64) {
	data := m.ContractInput

	// Handle empty input case
	if len(data) == 0 {
		m.WriteRegister(registerId, 0, 0)
		return
	}

	m.WriteRegister(registerId, uint64(len(data)), uint64(uintptr(unsafe.Pointer(&data[0]))))
}

// Helper function to safely get minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func (m *MockSystem) BlockIndex() uint64 {
	return m.BlockIndexSys
}

func (m *MockSystem) BlockTimestamp() uint64 {
	return m.BlockTimestampSys
}

func (m *MockSystem) EpochHeight() uint64 {
	return m.EpochHeightSys
}

func (m *MockSystem) StorageUsage() uint64 {
	return m.StorageUsageSys
}

// Context API

// Economics API
func (m *MockSystem) AccountBalance(balancePtr uint64) {
	balanceBytes := m.AccountBalanceSys.ToLE()
	targetBytes := (*[16]byte)(unsafe.Pointer(uintptr(balancePtr)))
	copy(targetBytes[:], balanceBytes)
}

func (m *MockSystem) AccountLockedBalance(balancePtr uint64) {
	balanceBytes := m.AccountLockedBalanceSys.ToLE()
	targetBytes := (*[16]byte)(unsafe.Pointer(uintptr(balancePtr)))
	copy(targetBytes[:], balanceBytes)
}

func (m *MockSystem) AttachedDeposit(balancePtr uint64) {
	balanceBytes := m.AttachedDepositSys.ToLE()
	targetBytes := (*[16]byte)(unsafe.Pointer(uintptr(balancePtr)))
	copy(targetBytes[:], balanceBytes)
}

func (m *MockSystem) PrepaidGas() uint64 {
	return m.PrepaidGasSys
}

func (m *MockSystem) UsedGas() uint64 {
	return m.UsedGasSys
}

// Math API

func (m *MockSystem) RandomSeed(registerId uint64) {
	seed := []byte("randomSeed")
	m.WriteRegister(registerId, uint64(len(seed)), uint64(uintptr(unsafe.Pointer(&seed[0]))))
}

func (m *MockSystem) Sha256(valueLen, valuePtr, registerId uint64) {
	hash := []byte("hash")
	m.WriteRegister(registerId, uint64(len(hash)), uint64(uintptr(unsafe.Pointer(&hash[0]))))
}

func (m *MockSystem) Keccak256(valueLen, valuePtr, registerId uint64) {
	hash := []byte("hash")
	m.WriteRegister(registerId, uint64(len(hash)), uint64(uintptr(unsafe.Pointer(&hash[0]))))
}

func (m *MockSystem) Keccak512(valueLen, valuePtr, registerId uint64) {
	hash := []byte("hash")
	m.WriteRegister(registerId, uint64(len(hash)), uint64(uintptr(unsafe.Pointer(&hash[0]))))
}

func (m *MockSystem) Ripemd160(valueLen, valuePtr, registerId uint64) {
	hash := []byte("hash")
	m.WriteRegister(registerId, uint64(len(hash)), uint64(uintptr(unsafe.Pointer(&hash[0]))))
}

func (m *MockSystem) Ecrecover(hashLen, hashPtr, sigLen, sigPtr, v, malleabilityFlag, registerId uint64) uint64 {
	return 1
}

func (m *MockSystem) Ed25519Verify(sigLen, sigPtr, msgLen, msgPtr, pubKeyLen, pubKeyPtr uint64) uint64 {
	return 1
}

func (m *MockSystem) AltBn128G1Multiexp(valueLen, valuePtr, registerId uint64) {
	simpleMultiexp := []byte("simpleMultiexp")
	m.WriteRegister(registerId, uint64(len(simpleMultiexp)), uint64(uintptr(unsafe.Pointer(&simpleMultiexp[0]))))
}

func (m *MockSystem) AltBn128G1SumSystem(valueLen, valuePtr, registerId uint64) {
	simpleSum := []byte("simpleSum")
	m.WriteRegister(registerId, uint64(len(simpleSum)), uint64(uintptr(unsafe.Pointer(&simpleSum[0]))))
}

func (m *MockSystem) AltBn128PairingCheckSystem(valueLen, valuePtr uint64) uint64 {
	return 1
}

// Math API

// Validator API

func (m *MockSystem) ValidatorStake(accountIdLen, accountIdPtr, stakePtr uint64) {
	expectedStake := types.Uint128{Hi: 0, Lo: 100000}
	stakeData := expectedStake.ToLE()

	copy((*(*[16]byte)(unsafe.Pointer(uintptr(stakePtr))))[:], stakeData)
}

func (m *MockSystem) ValidatorTotalStake(stakePtr uint64) {
	expectedStake := types.Uint128{Hi: 0, Lo: 100000}
	stakeData := expectedStake.ToLE()

	copy((*(*[16]byte)(unsafe.Pointer(uintptr(stakePtr))))[:], stakeData)
}

// Validator API

// Miscellaneous API

func (m *MockSystem) ValueReturn(valueLen, valuePtr uint64) {
	m.WriteRegister(0, valueLen, valuePtr)
}

func (m *MockSystem) PanicUtf8(len, ptr uint64) {
	// value := make([]byte, len)
	// copy(value, *(*[]byte)(unsafe.Pointer(uintptr(ptr))))

	// fmt.Printf("Panic: %s", value[:len])
}

func (m *MockSystem) LogUtf8(len, ptr uint64) {
	// value := make([]byte, len)
	// copy(value, *(*[]byte)(unsafe.Pointer(uintptr(ptr))))
	// fmt.Printf("Log: %s", value[:len])
}

func (m *MockSystem) LogUtf16(len, ptr uint64) {
	// utf16Bytes := make([]uint16, len/2)
	// for i := 0; i < int(len)/2; i++ {
	// 	utf16Bytes[i] = *(*uint16)(unsafe.Pointer(uintptr(ptr) + uintptr(i*2)))
	// }
	// message := string(utf16.Decode(utf16Bytes))
	// fmt.Printf("Log: %s", message)
}

// Miscellaneous API

// Promises API
func (m *MockSystem) PromiseCreate(accountIdLen, accountIdPtr, functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, amountPtr, gas uint64) uint64 {
	accountId := "accountId"
	functionName := "functionName"
	arguments := []byte("arguments")
	amount := types.Uint128{Lo: 0, Hi: 0}

	promise := MockPromise{
		AccountId:    accountId[:accountIdLen],
		FunctionName: functionName[:functionNameLen],
		Arguments:    arguments[:argumentsLen],
		Amount:       amount,
		Gas:          gas,
		PromiseIndex: uint64(len(m.Promises)),
	}

	m.Promises = append(m.Promises, promise)

	return promise.PromiseIndex
}

func (m *MockSystem) PromiseThen(promiseIndex, accountIdLen, accountIdPtr, functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, amountPtr, gas uint64) uint64 {
	accountId := "accountId"
	functionName := "functionName"
	arguments := []byte("arguments")
	amount := types.Uint128{Lo: 0, Hi: 0}

	promise := MockPromise{
		AccountId:    accountId,
		FunctionName: functionName,
		Arguments:    arguments,
		Amount:       amount,
		Gas:          gas,
		PromiseIndex: uint64(len(m.Promises)),
	}

	m.Promises = append(m.Promises, promise)

	return promise.PromiseIndex
}

func (m *MockSystem) PromiseAnd(promiseIdxPtr, promiseIdxCount uint64) uint64 {
	return uint64(2)
}

func (m *MockSystem) PromiseBatchCreate(accountIdLen, accountIdPtr uint64) uint64 {
	return 0
}

func (m *MockSystem) PromiseBatchThen(promiseIndex, accountIdLen, accountIdPtr uint64) uint64 {
	return 1
}

// Promises API

// Promise API Actions

func (m *MockSystem) PromiseBatchActionCreateAccount(promiseIndex uint64) {
}

func (m *MockSystem) PromiseBatchActionDeployContract(promiseIndex, codeLen, codePtr uint64) {
	contractBytes := make([]byte, codeLen)
	copy(contractBytes, *(*[]byte)(unsafe.Pointer(uintptr(codePtr))))
}

func (m *MockSystem) PromiseBatchActionFunctionCall(promiseIndex, functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, amountPtr, gas uint64) {
	functionName := make([]byte, functionNameLen)
	copy(functionName, *(*[]byte)(unsafe.Pointer(uintptr(functionNamePtr))))
	arguments := make([]byte, argumentsLen)
	copy(arguments, *(*[]byte)(unsafe.Pointer(uintptr(argumentsPtr))))
	binary.LittleEndian.Uint64((*(*[8]byte)(unsafe.Pointer(uintptr(amountPtr))))[:])

}

func (m *MockSystem) PromiseBatchActionFunctionCallWeight(promiseIndex, functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, amountPtr, gas, weight uint64) {
	functionName := make([]byte, functionNameLen)
	copy(functionName, *(*[]byte)(unsafe.Pointer(uintptr(functionNamePtr))))
	arguments := make([]byte, argumentsLen)
	copy(arguments, *(*[]byte)(unsafe.Pointer(uintptr(argumentsPtr))))
	binary.LittleEndian.Uint64((*(*[8]byte)(unsafe.Pointer(uintptr(amountPtr))))[:])

}

func (m *MockSystem) PromiseBatchActionTransfer(promiseIndex, amountPtr uint64) {
	binary.LittleEndian.Uint64((*(*[8]byte)(unsafe.Pointer(uintptr(amountPtr))))[:])
}

func (m *MockSystem) PromiseBatchActionStake(promiseIndex, amountPtr, publicKeyLen, publicKeyPtr uint64) {
	binary.LittleEndian.Uint64((*(*[8]byte)(unsafe.Pointer(uintptr(amountPtr))))[:])
	publicKey := make([]byte, publicKeyLen)
	copy(publicKey, *(*[]byte)(unsafe.Pointer(uintptr(publicKeyPtr))))

}

func (m *MockSystem) PromiseBatchActionAddKeyWithFullAccess(promiseIndex, publicKeyLen, publicKeyPtr, nonce uint64) {
	publicKey := make([]byte, publicKeyLen)
	copy(publicKey, *(*[]byte)(unsafe.Pointer(uintptr(publicKeyPtr))))
}

func (m *MockSystem) PromiseBatchActionAddKeyWithFunctionCall(promiseIndex, publicKeyLen, publicKeyPtr, nonce, allowancePtr, receiverIdLen, receiverIdPtr, functionNamesLen, functionNamesPtr uint64) {
	publicKey := make([]byte, publicKeyLen)
	copy(publicKey, *(*[]byte)(unsafe.Pointer(uintptr(publicKeyPtr))))
	binary.LittleEndian.Uint64((*(*[8]byte)(unsafe.Pointer(uintptr(allowancePtr))))[:])

	receiverId := make([]byte, receiverIdLen)
	copy(receiverId, *(*[]byte)(unsafe.Pointer(uintptr(receiverIdPtr))))
	functionNames := make([]byte, functionNamesLen)
	copy(functionNames, *(*[]byte)(unsafe.Pointer(uintptr(functionNamesPtr))))
}

func (m *MockSystem) PromiseBatchActionDeleteKey(promiseIndex, publicKeyLen, publicKeyPtr uint64) {
	publicKey := make([]byte, publicKeyLen)
	copy(publicKey, *(*[]byte)(unsafe.Pointer(uintptr(publicKeyPtr))))
}

func (m *MockSystem) PromiseBatchActionDeleteAccount(promiseIndex, beneficiaryIdLen, beneficiaryIdPtr uint64) {
	beneficiaryId := make([]byte, beneficiaryIdLen)
	copy(beneficiaryId, *(*[]byte)(unsafe.Pointer(uintptr(beneficiaryIdPtr))))
}

func (m *MockSystem) PromiseYieldCreate(functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, gas, gasWeight, registerId uint64) uint64 {
	return 1
}

func (m *MockSystem) PromiseYieldResume(dataIdLen, dataIdPtr, payloadLen, payloadPtr uint64) uint32 {
	return 1
}

// Promise API Actions

// Promise API Results
func (m *MockSystem) PromiseResultsCount() uint64 {
	return uint64(len(m.Promises))
}

func (m *MockSystem) PromiseResult(resultIdx uint64, registerId uint64) uint64 {
	if resultIdx < uint64(len(m.Promises)) {
		result := m.Promises[resultIdx].Arguments
		m.WriteRegister(registerId, uint64(len(result)), uint64(uintptr(unsafe.Pointer(&result[0]))))
		return 1 // Return a success indicator
	}
	return 0 // Return a failure indicator
}

func (m *MockSystem) PromiseReturn(promiseId uint64) {
	if promiseId < uint64(len(m.Promises)) {
		m.Registers[0] = m.Promises[promiseId].Arguments
	}
}

// Promise API Results



==================================================
FILE: system/system_mock_test.go
==================================================

package system

import (
	"bytes"
	"testing"
	"unsafe"

	"github.com/vlmoon99/near-sdk-go/types"
)

// Registers API

func TestReadRegister(t *testing.T) {
	mockSys := NewMockSystem()
	mockSys.Registers[1] = []byte("test data")

	var buffer = make([]byte, len(mockSys.Registers[1]))
	ptr := uintptr(unsafe.Pointer(&buffer[0]))
	mockSys.ReadRegister(1, uint64(ptr))

	if string(buffer) != "test data" {
		t.Errorf("expected 'test data', got %s", string(buffer))
	}
}

func TestRegisterLen(t *testing.T) {
	mockSys := NewMockSystem()
	mockSys.Registers[1] = []byte("test data")

	length := mockSys.RegisterLen(1)
	expectedLength := uint64(len(mockSys.Registers[1]))

	if length != expectedLength {
		t.Errorf("expected length %d, got %d", expectedLength, length)
	}
}

func TestWriteRegister(t *testing.T) {
	mockSys := NewMockSystem()
	data := []byte("test data")
	var buffer = make([]byte, len(data))
	copy(buffer, data)

	ptr := uintptr(unsafe.Pointer(&buffer[0]))
	mockSys.WriteRegister(1, uint64(len(data)), uint64(ptr))

	if string(mockSys.Registers[1]) != "test data" {
		t.Errorf("expected 'test data', got %s", string(mockSys.Registers[1]))
	}
}

func TestWriteAndReadRegister(t *testing.T) {
	mockSys := NewMockSystem()
	data := []byte("test data")
	var buffer = make([]byte, len(data))
	copy(buffer, data)

	ptr := uintptr(unsafe.Pointer(&buffer[0]))
	mockSys.WriteRegister(1, uint64(len(data)), uint64(ptr))

	var readBuffer = make([]byte, len(data))
	readPtr := uintptr(unsafe.Pointer(&readBuffer[0]))
	mockSys.ReadRegister(1, uint64(readPtr))

	if string(readBuffer) != "test data" {
		t.Errorf("expected 'test data', got %s", string(readBuffer))
	}
}

// Registers API

// Storage API
func TestStorageWrite(t *testing.T) {
	mockSys := NewMockSystem()
	key := "testKey"
	value := "testValue"
	var keyBuffer = []byte(key)
	var valueBuffer = []byte(value)
	keyPtr := uintptr(unsafe.Pointer(&keyBuffer[0]))
	valuePtr := uintptr(unsafe.Pointer(&valueBuffer[0]))

	result := mockSys.StorageWrite(uint64(len(keyBuffer)), uint64(keyPtr), uint64(len(valueBuffer)), uint64(valuePtr), 0)
	if result != 1 {
		t.Errorf("expected 1, got %d", result)
	}

	if string(mockSys.Storage[key]) != value {
		t.Errorf("expected '%s', got '%s'", value, mockSys.Storage[key])
	}

	// Update existing key
	newValue := "newValue"
	var newValueBuffer = []byte(newValue)
	valuePtr = uintptr(unsafe.Pointer(&newValueBuffer[0]))
	result = mockSys.StorageWrite(uint64(len(keyBuffer)), uint64(keyPtr), uint64(len(newValueBuffer)), uint64(valuePtr), 0)
	if result != 1 {
		t.Errorf("expected 1, got %d", result)
	}

	if string(mockSys.Storage[key]) != newValue {
		t.Errorf("expected '%s', got '%s'", newValue, mockSys.Storage[key])
	}
}

func TestStorageRead(t *testing.T) {
	mockSys := NewMockSystem()
	key := "testKey"
	value := "testValue"
	mockSys.Storage[key] = []byte(value)
	var keyBuffer = []byte(key)
	keyPtr := uintptr(unsafe.Pointer(&keyBuffer[0]))

	registerId := uint64(1)
	result := mockSys.StorageRead(uint64(len(keyBuffer)), uint64(keyPtr), registerId)
	if result != 1 {
		t.Errorf("expected 1, got %d", result)
	}

	readValue := mockSys.Registers[registerId]
	if string(readValue) != value {
		t.Errorf("expected '%s', got '%s'", value, readValue)
	}

	// Read non-existing key
	nonExistingKey := "nonExistingKey"
	var nonExistingKeyBuffer = []byte(nonExistingKey)
	keyPtr = uintptr(unsafe.Pointer(&nonExistingKeyBuffer[0]))
	result = mockSys.StorageRead(uint64(len(nonExistingKeyBuffer)), uint64(keyPtr), registerId)
	if result != 0 {
		t.Errorf("expected 0, got %d", result)
	}
}

func TestStorageRemove(t *testing.T) {
	mockSys := NewMockSystem()
	key := "testKey"
	value := "testValue"
	mockSys.Storage[key] = []byte(value)
	var keyBuffer = []byte(key)
	keyPtr := uintptr(unsafe.Pointer(&keyBuffer[0]))

	registerId := uint64(1)
	result := mockSys.StorageRemove(uint64(len(keyBuffer)), uint64(keyPtr), registerId)
	if result != 1 {
		t.Errorf("expected 1, got %d", result)
	}

	if _, exists := mockSys.Storage[key]; exists {
		t.Errorf("expected key to be removed")
	}

	// Remove non-existing key
	nonExistingKey := "nonExistingKey"
	var nonExistingKeyBuffer = []byte(nonExistingKey)
	keyPtr = uintptr(unsafe.Pointer(&nonExistingKeyBuffer[0]))
	result = mockSys.StorageRemove(uint64(len(nonExistingKeyBuffer)), uint64(keyPtr), registerId)
	if result != 0 {
		t.Errorf("expected 0, got %d", result)
	}
}

func TestStorageHasKey(t *testing.T) {
	mockSys := NewMockSystem()
	key := "testKey"
	value := "testValue"
	mockSys.Storage[key] = []byte(value)
	var keyBuffer = []byte(key)
	keyPtr := uintptr(unsafe.Pointer(&keyBuffer[0]))

	result := mockSys.StorageHasKey(uint64(len(keyBuffer)), uint64(keyPtr))
	if result != 1 {
		t.Errorf("expected 1, got %d", result)
	}

	// Check non-existing key
	nonExistingKey := "nonExistingKey"
	var nonExistingKeyBuffer = []byte(nonExistingKey)
	keyPtr = uintptr(unsafe.Pointer(&nonExistingKeyBuffer[0]))
	result = mockSys.StorageHasKey(uint64(len(nonExistingKeyBuffer)), uint64(keyPtr))
	if result != 0 {
		t.Errorf("expected 0, got %d", result)
	}
}

// Storage API

// Context API

func TestCurrentAccountId(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	mockSys.CurrentAccountId(registerId)

	if data, exists := mockSys.Registers[registerId]; !exists || string(data) != mockSys.CurrentAccountIdSys {
		t.Errorf("expected %s, got %s", mockSys.CurrentAccountIdSys, string(data))
	}
}

func TestSignerAccountId(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	mockSys.SignerAccountId(registerId)

	if data, exists := mockSys.Registers[registerId]; !exists || string(data) != mockSys.SignerAccountIdSys {
		t.Errorf("expected %s, got %s", mockSys.SignerAccountIdSys, string(data))
	}
}

func TestSignerAccountPk(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	mockSys.SignerAccountPk(registerId)

	if data, exists := mockSys.Registers[registerId]; !exists || !bytes.Equal(data, mockSys.SignerAccountPkSys) {
		t.Errorf("expected %s, got %s", string(mockSys.SignerAccountPkSys), string(data))
	}
}

func TestPredecessorAccountId(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	mockSys.PredecessorAccountId(registerId)

	if data, exists := mockSys.Registers[registerId]; !exists || string(data) != mockSys.PredecessorAccountIdSys {
		t.Errorf("expected %s, got %s", mockSys.PredecessorAccountIdSys, string(data))
	}
}

func TestInput(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	mockSys.Input(registerId)

	if data, exists := mockSys.Registers[registerId]; !exists || !bytes.Equal(data, mockSys.ContractInput) {
		t.Errorf("expected %s, got %s", string(mockSys.ContractInput), string(data))
	}
}

func TestBlockIndex(t *testing.T) {
	mockSys := NewMockSystem()
	expected := mockSys.BlockIndexSys
	result := mockSys.BlockIndex()

	if expected != result {
		t.Errorf("expected %d, got %d", expected, result)
	}
}

func TestBlockTimestamp(t *testing.T) {
	mockSys := NewMockSystem()
	expected := mockSys.BlockTimestampSys
	result := mockSys.BlockTimestamp()

	if expected != result {
		t.Errorf("expected %d, got %d", expected, result)
	}
}

func TestEpochHeight(t *testing.T) {
	mockSys := NewMockSystem()
	expected := mockSys.EpochHeightSys
	result := mockSys.EpochHeight()

	if expected != result {
		t.Errorf("expected %d, got %d", expected, result)
	}
}

func TestStorageUsage(t *testing.T) {
	mockSys := NewMockSystem()
	expected := mockSys.StorageUsageSys
	result := mockSys.StorageUsage()

	if expected != result {
		t.Errorf("expected %d, got %d", expected, result)
	}
}

// Context API

// Economics API

func TestAccountBalance(t *testing.T) {
	mockSys := NewMockSystem()
	var data [16]byte
	mockSys.AccountBalance(uint64(uintptr(unsafe.Pointer(&data[0]))))

	expected := mockSys.AccountBalanceSys.ToLE()
	if string(data[:]) != string(expected) {
		t.Errorf("expected %v, got %v", expected, data[:])
	}
}

func TestAccountLockedBalance(t *testing.T) {
	mockSys := NewMockSystem()
	var data [16]byte
	mockSys.AccountLockedBalance(uint64(uintptr(unsafe.Pointer(&data[0]))))

	expected := mockSys.AccountLockedBalanceSys.ToLE()
	if string(data[:]) != string(expected) {
		t.Errorf("expected %v, got %v", expected, data[:])
	}
}

func TestAttachedDeposit(t *testing.T) {
	mockSys := NewMockSystem()
	var data [16]byte
	mockSys.AttachedDeposit(uint64(uintptr(unsafe.Pointer(&data[0]))))

	expected := mockSys.AttachedDepositSys.ToLE()
	if string(data[:]) != string(expected) {
		t.Errorf("expected %v, got %v", expected, data[:])
	}
}

func TestPrepaidGas(t *testing.T) {
	mockSys := NewMockSystem()
	expected := mockSys.PrepaidGasSys
	result := mockSys.PrepaidGas()

	if expected != result {
		t.Errorf("expected %d, got %d", expected, result)
	}
}

func TestUsedGas(t *testing.T) {
	mockSys := NewMockSystem()
	expected := mockSys.UsedGasSys
	result := mockSys.UsedGas()

	if expected != result {
		t.Errorf("expected %d, got %d", expected, result)
	}
}

// Economics API

// Math API

func TestRandomSeed(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	mockSys.RandomSeed(registerId)

	if _, exists := mockSys.Registers[registerId]; !exists {
		t.Errorf("expected random seed to be written to register %d", registerId)
	}
}

func TestSha256(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	data := []byte("test data")
	dataPtr := uintptr(unsafe.Pointer(&data[0]))

	mockSys.Sha256(uint64(len(data)), uint64(dataPtr), registerId)

	expected := "hash"
	if string(mockSys.Registers[registerId]) != expected {
		t.Errorf("expected %s, got %s", expected, string(mockSys.Registers[registerId]))
	}
}

func TestKeccak256(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	data := []byte("test data")
	dataPtr := uintptr(unsafe.Pointer(&data[0]))

	mockSys.Keccak256(uint64(len(data)), uint64(dataPtr), registerId)

	expected := "hash"
	if string(mockSys.Registers[registerId]) != expected {
		t.Errorf("expected %s, got %s", expected, string(mockSys.Registers[registerId]))
	}
}

func TestKeccak512(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	data := []byte("test data")
	dataPtr := uintptr(unsafe.Pointer(&data[0]))

	mockSys.Keccak512(uint64(len(data)), uint64(dataPtr), registerId)

	expected := "hash"
	if string(mockSys.Registers[registerId]) != expected {
		t.Errorf("expected %s, got %s", expected, string(mockSys.Registers[registerId]))
	}
}

func TestRipemd160(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	data := []byte("test data")
	dataPtr := uintptr(unsafe.Pointer(&data[0]))

	mockSys.Ripemd160(uint64(len(data)), uint64(dataPtr), registerId)

	expected := "hash"
	if string(mockSys.Registers[registerId]) != expected {
		t.Errorf("expected %s, got %s", expected, string(mockSys.Registers[registerId]))
	}
}

func TestAltBn128G1Multiexp(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	data := []byte{1, 2, 3, 4, 5}
	dataPtr := uintptr(unsafe.Pointer(&data[0]))

	mockSys.AltBn128G1Multiexp(uint64(len(data)), uint64(dataPtr), registerId)

	expected := "simpleMultiexp"

	if string(mockSys.Registers[registerId]) != expected {
		t.Errorf("expected 'simpleMultiexp', got %s", string(mockSys.Registers[registerId]))
	}
}

func TestAltBn128G1SumSystem(t *testing.T) {
	mockSys := NewMockSystem()
	registerId := uint64(1)
	data := []byte{1, 2, 3, 4, 5}
	dataPtr := uintptr(unsafe.Pointer(&data[0]))

	mockSys.AltBn128G1SumSystem(uint64(len(data)), uint64(dataPtr), registerId)

	expected := "simpleSum"

	if string(mockSys.Registers[registerId]) != expected {
		t.Errorf("expected 'simpleSum', got %s", string(mockSys.Registers[registerId]))
	}
}

// Math API

// Validator API

func TestValidatorStake(t *testing.T) {
	mockSys := NewMockSystem()
	accountId := "validatorAccountId"
	accountIdLen := uint64(len(accountId))
	accountIdPtr := uintptr(unsafe.Pointer(&accountId))

	var stakeData uint64
	stakePtr := uintptr(unsafe.Pointer(&stakeData))

	mockSys.ValidatorStake(accountIdLen, uint64(accountIdPtr), uint64(stakePtr))

	expectedStake := uint64(100000)
	if stakeData != expectedStake {
		t.Errorf("expected stake %d, got %d", expectedStake, stakeData)
	}
}

func TestValidatorTotalStake(t *testing.T) {
	mockSys := NewMockSystem()
	var stakeData uint64
	stakePtr := uintptr(unsafe.Pointer(&stakeData))

	mockSys.ValidatorTotalStake(uint64(stakePtr))

	expectedStake := uint64(100000)
	if stakeData != expectedStake {
		t.Errorf("expected total stake %d, got %d", expectedStake, stakeData)
	}
}

// Validator API

// Miscellaneous API

func TestValueReturn(t *testing.T) {
	mockSys := NewMockSystem()
	data := []byte("test data")
	var buffer = make([]byte, len(data))
	copy(buffer, data)

	ptr := uintptr(unsafe.Pointer(&buffer[0]))

	mockSys.ValueReturn(uint64(len(data)), uint64(ptr))

	if string(mockSys.Registers[0]) != string(data) {
		t.Errorf("expected %s, got %s", string(data), string(mockSys.Registers[0]))
	}
}

// Miscellaneous API

// Promises API

func TestPromiseCreate(t *testing.T) {
	mockSys := NewMockSystem()
	accountId := "accountId"
	functionName := "functionName"
	arguments := []byte("arguments")
	amount := types.Uint128{Lo: 0, Hi: 0}
	gas := uint64(5000)

	accountIdPtr := uintptr(unsafe.Pointer(&accountId))
	functionNamePtr := uintptr(unsafe.Pointer(&functionName))
	argumentsPtr := uintptr(unsafe.Pointer(&arguments[0]))
	amountPtr := uintptr(unsafe.Pointer(&amount))

	promiseIndex := mockSys.PromiseCreate(uint64(len(accountId)), uint64(accountIdPtr),
		uint64(len(functionName)), uint64(functionNamePtr),
		uint64(len(arguments)), uint64(argumentsPtr),
		uint64(amountPtr), gas)

	expectedIndex := uint64(0)
	if promiseIndex != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIndex)
	}

	if len(mockSys.Promises) != 1 {
		t.Errorf("expected 1 promise, got %d", len(mockSys.Promises))
	}

	promise := mockSys.Promises[0]
	if promise.AccountId != accountId {
		t.Errorf("expected account id %s, got %s", accountId, promise.AccountId)
	}
	if promise.FunctionName != functionName {
		t.Errorf("expected function name %s, got %s", functionName, promise.FunctionName)
	}
	if string(promise.Arguments) != string(arguments) {
		t.Errorf("expected arguments %s, got %s", string(arguments), string(promise.Arguments))
	}
	if promise.Amount != amount {
		t.Errorf("expected amount %d, got %d", amount, promise.Amount)
	}
	if promise.Gas != gas {
		t.Errorf("expected gas %d, got %d", gas, promise.Gas)
	}
}

func TestPromiseThen(t *testing.T) {
	mockSys := NewMockSystem()

	// Create the first promise
	accountId := "accountId"
	functionName := "functionName"
	arguments := []byte("arguments")
	amount := types.Uint128{Lo: 0, Hi: 0}
	gas := uint64(5000)

	accountIdPtr := uintptr(unsafe.Pointer(&accountId))
	functionNamePtr := uintptr(unsafe.Pointer(&functionName))
	argumentsPtr := uintptr(unsafe.Pointer(&arguments[0]))
	amountPtr := uintptr(unsafe.Pointer(&amount))

	// Create the first promise
	mockSys.PromiseCreate(
		uint64(len(accountId)), uint64(accountIdPtr),
		uint64(len(functionName)), uint64(functionNamePtr),
		uint64(len(arguments)), uint64(argumentsPtr),
		uint64(amountPtr), gas,
	)

	promiseIdx := uint64(0)
	promiseIndex := mockSys.PromiseThen(
		promiseIdx,
		uint64(len(accountId)), uint64(accountIdPtr),
		uint64(len(functionName)), uint64(functionNamePtr),
		uint64(len(arguments)), uint64(argumentsPtr),
		uint64(amountPtr), gas,
	)

	expectedIndex := uint64(1)
	if promiseIndex != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIndex)
	}

	if len(mockSys.Promises) != 2 {
		t.Errorf("expected 2 promises, got %d", len(mockSys.Promises))
	}

	promise := mockSys.Promises[1]
	if promise.AccountId != accountId {
		t.Errorf("expected account id %s, got %s", accountId, promise.AccountId)
	}
	if promise.FunctionName != functionName {
		t.Errorf("expected function name %s, got %s", functionName, promise.FunctionName)
	}
	if string(promise.Arguments) != string(arguments) {
		t.Errorf("expected arguments %s, got %s", string(arguments), string(promise.Arguments))
	}
	if promise.Amount.Lo != amount.Lo {
		t.Errorf("expected amount %d, got %d", amount.Lo, promise.Amount)
	}
	if promise.Gas != gas {
		t.Errorf("expected gas %d, got %d", gas, promise.Gas)
	}
}

func TestPromiseAnd(t *testing.T) {
	mockSys := NewMockSystem()
	promiseIndices := []uint64{0, 1}
	promiseIdxPtr := uintptr(unsafe.Pointer(&promiseIndices[0]))

	promiseIndex := mockSys.PromiseAnd(uint64(promiseIdxPtr), uint64(len(promiseIndices)))

	expectedIndex := uint64(2)
	if promiseIndex != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIndex)
	}
}

func TestPromiseBatchCreate(t *testing.T) {
	mockSys := NewMockSystem()
	accountId := "accountId"
	accountIdPtr := uintptr(unsafe.Pointer(&accountId))

	promiseIndex := mockSys.PromiseBatchCreate(uint64(len(accountId)), uint64(accountIdPtr))

	expectedIndex := uint64(0)
	if promiseIndex != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIndex)
	}
}

func TestPromiseBatchThen(t *testing.T) {
	mockSys := NewMockSystem()
	accountId := "accountId"
	accountIdPtr := uintptr(unsafe.Pointer(&accountId))
	promiseIdx := uint64(0)

	promiseIndex := mockSys.PromiseBatchThen(promiseIdx, uint64(len(accountId)), uint64(accountIdPtr))

	expectedIndex := uint64(1)
	if promiseIndex != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIndex)
	}
}

// Promises API

// Promises API Action

func TestPromiseBatchActionCreateAccount(t *testing.T) {
	mockSys := MockSystem{}
	promiseIdx := uint64(0)

	mockSys.PromiseBatchActionCreateAccount(promiseIdx)

}

func TestPromiseBatchActionDeployContract(t *testing.T) {
	mockSys := MockSystem{}
	promiseIdx := uint64(0)
	contractBytes := []byte("sample contract bytes")
	codeLen := uint64(len(contractBytes))
	codePtr := uintptr(unsafe.Pointer(&contractBytes[0]))

	mockSys.PromiseBatchActionDeployContract(promiseIdx, codeLen, uint64(codePtr))

}

func TestPromiseBatchActionFunctionCall(t *testing.T) {
	mockSys := MockSystem{}
	promiseIdx := uint64(0)
	functionName := []byte("TestLogStringUtf8")
	functionNameLen := uint64(len(functionName))
	functionNamePtr := uintptr(unsafe.Pointer(&functionName[0]))
	arguments := []byte("{}")
	argumentsLen := uint64(len(arguments))
	argumentsPtr := uintptr(unsafe.Pointer(&arguments[0]))
	amount := types.Uint128{Hi: 0, Lo: 0}
	amountPtr := uintptr(unsafe.Pointer(&amount))
	gas := uint64(3000000000)

	mockSys.PromiseBatchActionFunctionCall(promiseIdx, functionNameLen, uint64(functionNamePtr), argumentsLen, uint64(argumentsPtr), uint64(amountPtr), gas)

}

func TestPromiseBatchActionFunctionCallWeight(t *testing.T) {
	mockSys := MockSystem{}
	promiseIdx := uint64(0)
	functionName := []byte("TestLogStringUtf8")
	functionNameLen := uint64(len(functionName))
	functionNamePtr := uintptr(unsafe.Pointer(&functionName[0]))
	arguments := []byte("{}")
	argumentsLen := uint64(len(arguments))
	argumentsPtr := uintptr(unsafe.Pointer(&arguments[0]))
	amount := types.Uint128{Hi: 0, Lo: 0}
	amountPtr := uintptr(unsafe.Pointer(&amount))
	gas := uint64(3000000000)
	weight := uint64(1)

	mockSys.PromiseBatchActionFunctionCallWeight(promiseIdx, functionNameLen, uint64(functionNamePtr), argumentsLen, uint64(argumentsPtr), uint64(amountPtr), gas, weight)
}

func TestPromiseBatchActionTransfer(t *testing.T) {
	mockSys := MockSystem{}
	promiseIdx := uint64(0)
	amount, _ := types.U128FromString("10000000000000000000000") // 0.01 Near
	amountPtr := uintptr(unsafe.Pointer(&amount))
	mockSys.PromiseBatchActionTransfer(promiseIdx, uint64(amountPtr))
}

func TestPromiseBatchActionStake(t *testing.T) {
	mockSys := MockSystem{}
	promiseIdx := uint64(0)
	amount, _ := types.U128FromString("10000000000000000000000") // 0.01 Near
	amountPtr := uintptr(unsafe.Pointer(&amount))
	signerPK := []byte("sample_signer_public_key")
	publicKeyLen := uint64(len(signerPK))
	publicKeyPtr := uintptr(unsafe.Pointer(&signerPK[0]))

	mockSys.PromiseBatchActionStake(promiseIdx, uint64(amountPtr), publicKeyLen, uint64(publicKeyPtr))
}

func TestPromiseBatchActionAddKeyWithFullAccess(t *testing.T) {
	mockSys := MockSystem{}
	promiseIdx := uint64(0)
	publicKey, _ := types.PublicKeyFromString("ed25519:ExeqWPvjcUjLX3NfTk3JzisaXLjsCqJNZFCj7ub92RQW")
	publicKeyLen := uint64(len(publicKey.Bytes()))
	publicKeyPtr := uintptr(unsafe.Pointer(&publicKey.Bytes()[0]))
	nonce := uint64(0)

	mockSys.PromiseBatchActionAddKeyWithFullAccess(promiseIdx, publicKeyLen, uint64(publicKeyPtr), nonce)
}

func TestPromiseBatchActionAddKeyWithFunctionCall(t *testing.T) {
	mockSys := MockSystem{}
	promiseIdx := uint64(0)
	publicKey, _ := types.PublicKeyFromString("ed25519:ExeqWPvjcUjLX3NfTk3JzisaXLjsCqJNZFCj7ub92RQW")
	publicKeyLen := uint64(len(publicKey.Bytes()))
	publicKeyPtr := uintptr(unsafe.Pointer(&publicKey.Bytes()[0]))
	nonce := uint64(0)
	amount := types.Uint128{Hi: 0, Lo: 1000}
	amountPtr := uintptr(unsafe.Pointer(&amount))
	receiverId := []byte("receiver.near")
	receiverIdLen := uint64(len(receiverId))
	receiverIdPtr := uintptr(unsafe.Pointer(&receiverId[0]))
	functionName := []byte("TestLogStringUtf8")
	functionNameLen := uint64(len(functionName))
	functionNamePtr := uintptr(unsafe.Pointer(&functionName[0]))

	mockSys.PromiseBatchActionAddKeyWithFunctionCall(promiseIdx, publicKeyLen, uint64(publicKeyPtr), nonce, uint64(amountPtr), receiverIdLen, uint64(receiverIdPtr), functionNameLen, uint64(functionNamePtr))

}

func TestPromiseBatchActionDeleteKey(t *testing.T) {
	mockSys := MockSystem{}
	promiseIdx := uint64(0)
	publicKey, _ := types.PublicKeyFromString("ed25519:ExeqWPvjcUjLX3NfTk3JzisaXLjsCqJNZFCj7ub92RQW")
	publicKeyLen := uint64(len(publicKey.Bytes()))
	publicKeyPtr := uintptr(unsafe.Pointer(&publicKey.Bytes()[0]))
	mockSys.PromiseBatchActionDeleteKey(promiseIdx, publicKeyLen, uint64(publicKeyPtr))
}

func TestPromiseBatchActionDeleteAccount(t *testing.T) {
	mockSys := MockSystem{}
	promiseIdx := uint64(0)
	beneficiaryId := []byte("beneficiary.near")
	beneficiaryIdLen := uint64(len(beneficiaryId))
	beneficiaryIdPtr := uintptr(unsafe.Pointer(&beneficiaryId[0]))
	mockSys.PromiseBatchActionDeleteAccount(promiseIdx, beneficiaryIdLen, uint64(beneficiaryIdPtr))
}

func TestPromiseYieldCreate(t *testing.T) {
	mockSys := MockSystem{}
	functionName := []byte("TestContractValueReturn")
	functionNameLen := uint64(len(functionName))
	functionNamePtr := uintptr(unsafe.Pointer(&functionName[0]))
	arguments := []byte("{}")
	argumentsLen := uint64(len(arguments))
	argumentsPtr := uintptr(unsafe.Pointer(&arguments[0]))
	gas := uint64(3000000000)
	gasWeight := uint64(0)
	registerId := uint64(0)

	promiseIdx := mockSys.PromiseYieldCreate(functionNameLen, uint64(functionNamePtr), argumentsLen, uint64(argumentsPtr), gas, gasWeight, registerId)

	expectedIndex := uint64(1)
	if promiseIdx != expectedIndex {
		t.Errorf("expected promise index %d, got %d", expectedIndex, promiseIdx)
	}
}

func TestPromiseYieldResume(t *testing.T) {
	mockSys := MockSystem{}
	data := []byte("sample data")
	dataIdLen := uint64(len(data))
	dataIdPtr := uintptr(unsafe.Pointer(&data[0]))
	payload := []byte("sample payload")
	payloadLen := uint64(len(payload))
	payloadPtr := uintptr(unsafe.Pointer(&payload[0]))

	result := mockSys.PromiseYieldResume(dataIdLen, uint64(dataIdPtr), payloadLen, uint64(payloadPtr))

	expectedResult := uint32(1)
	if result != expectedResult {
		t.Errorf("expected result %d, got %d", expectedResult, result)
	}
}

// Promises API Action

// Promise API Results

func TestPromiseResultsCount(t *testing.T) {
	mockSys := MockSystem{}

	count := mockSys.PromiseResultsCount()
	expectedCount := uint64(0)
	if count != expectedCount {
		t.Errorf("expected promise count %d, got %d", expectedCount, count)
	}
}

func TestPromiseResult(t *testing.T) {
	mockSys := MockSystem{}

	resultIdx := uint64(0)
	registerId := uint64(0)

	status := mockSys.PromiseResult(resultIdx, registerId)
	expectedStatus := uint64(0)
	if status != expectedStatus {
		t.Errorf("expected status %d, got %d", expectedStatus, status)
	}
}

func TestPromiseReturn(t *testing.T) {
	mockSys := MockSystem{}
	promiseId := uint64(0)

	mockSys.PromiseReturn(promiseId)
}

func compareBytes(a, b []byte) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// Promise API Results



==================================================
FILE: system/system_near.go
==================================================

//go:build !staticcheck
// +build !staticcheck

package system

// This is the SystemNear class. It contains no internal structures or data.
// All storage and registers are provided by the NEAR Blockchain environment in the WASM runtime.
type SystemNear struct{}

// ReadRegister provides read register functionality.
//
// registerId is the ID of the register from which we want to read the data.
//
// ptr is a pointer to the buffer where this function will write the data from the register.
//
//go:wasmimport env read_register
func (SystemNear) ReadRegister(registerId, ptr uint64)

// RegisterLen provides register length retrieval functionality.
//
// registerId is the ID of the register whose length we want to obtain.
//
//go:wasmimport env register_len
func (SystemNear) RegisterLen(registerId uint64) uint64

// WriteRegister is a function that provides write register functionality.
//
// registerId is the ID of the register where we want to write the data.
//
// dataLen is the length of the data to be written.
//
// dataPtr is a pointer to the buffer containing the data to be written.
//
//go:wasmimport env write_register
func (SystemNear) WriteRegister(registerId, dataLen, dataPtr uint64)

// StorageWrite writes a key-value pair into storage.
// If a key-value pair with the same key already exists, it returns 1; otherwise, it returns 0.
// Storage functions are typically used to upgrade or migrate the contract state.
//
// keyLen is the length of the key.
//
// keyPtr is a pointer to the key.
//
// valueLen is the length of the value.
//
// valuePtr is a pointer to the value.
//
// registerId is the ID of the register where the operation result is stored.
//
//go:wasmimport env storage_write
func (SystemNear) StorageWrite(keyLen, keyPtr, valueLen, valuePtr, registerId uint64) uint64

// StorageRead reads the value stored under the given key.
// Storage functions are typically used to upgrade or migrate the contract state.
//
// keyLen is the length of the key.
//
// keyPtr is a pointer to the key.
//
// registerId is the ID of the register where the retrieved value is stored.
//
//go:wasmimport env storage_read
func (SystemNear) StorageRead(keyLen, keyPtr, registerId uint64) uint64

// StorageRemove removes the value stored under the given key.
// If the key-value pair existed, it returns 1; otherwise, it returns 0.
// Storage functions are typically used to upgrade or migrate the contract state.
//
// keyLen is the length of the key.
//
// keyPtr is a pointer to the key.
//
// registerId is the ID of the register where the operation result is stored.
//
//go:wasmimport env storage_remove
func (SystemNear) StorageRemove(keyLen, keyPtr, registerId uint64) uint64

// StorageHasKey checks if a key-value pair exists in the storage.
// Storage functions are typically used to upgrade or migrate the contract state.
//
// keyLen is the length of the key.
//
// keyPtr is a pointer to the key.
//
//go:wasmimport env storage_has_key
func (SystemNear) StorageHasKey(keyLen, keyPtr uint64) uint64

// CurrentAccountId retrieves the ID of the account that owns the current contract.
//
// registerId is the ID of the register where the current account ID will be written.
//
// For the standard implementation, it is set to `const AtomicOpRegister uint64 = math.MaxUint64 - 2`.
//
//go:wasmimport env current_account_id
func (SystemNear) CurrentAccountId(registerId uint64)

// SignerAccountId retrieves the ID of the account that signed the original transaction
// or issued the initial cross-contract call.
//
// registerId is the ID of the register where the signer account ID will be written.
//
// For the standard implementation, it is set to `const AtomicOpRegister uint64 = math.MaxUint64 - 2`.
//
//go:wasmimport env signer_account_id
func (SystemNear) SignerAccountId(registerId uint64)

// SignerAccountPk retrieves the public key of the account that performed the signing.
//
// registerId is the ID of the register where the signer account public key will be written.
//
// For the standard implementation, it is set to `const AtomicOpRegister uint64 = math.MaxUint64 - 2`.
//
//go:wasmimport env signer_account_pk
func (SystemNear) SignerAccountPk(registerId uint64)

// PredecessorAccountId retrieves the ID of the account that was the previous contract
// in the chain of cross-contract calls.
// If this is the first contract, it is equal to `signer_account_id`.
//
// registerId is the ID of the register where the predecessor account ID will be written.
//
// For the standard implementation, it is set to `const AtomicOpRegister uint64 = math.MaxUint64 - 2`.
//
//go:wasmimport env predecessor_account_id
func (SystemNear) PredecessorAccountId(registerId uint64)

// Input retrieves the smart contract function input for the contract call, serialized as bytes.
//
// registerId is the ID of the register where the smart contract input will be written.
// For the standard implementation, it is set to `const AtomicOpRegister uint64 = math.MaxUint64 - 2`.
//
//go:wasmimport env input
func (SystemNear) Input(registerId uint64)

// BlockIndex retrieves the current block index (aka height of the current block)
//
//go:wasmimport env block_index
func (SystemNear) BlockIndex() uint64

// BlockTimestamp retrieves the current block timestamp, i.e, number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
//
//go:wasmimport env block_timestamp
func (SystemNear) BlockTimestamp() uint64

// EpochHeight retrieves the current epoch height
//
//go:wasmimport env epoch_height
func (SystemNear) EpochHeight() uint64

// StorageUsage retrieves the current total storage usage of this smart contract that this account would be paying for.
//
//go:wasmimport env storage_usage
func (SystemNear) StorageUsage() uint64

// AccountBalance retrieves the balance attached to the given account. This includes the attached_deposit that was
// attached to the transaction.
//
// balancePtr is a pointer to the buffer containing the data to be written.
//
//go:wasmimport env account_balance
func (SystemNear) AccountBalance(balancePtr uint64)

// AccountLockedBalance retrieves the balance that was attached to the call that will be immediately deposited before the
// contract execution starts.
//
// balancePtr is a pointer to the buffer containing the data to be written.
//
//go:wasmimport env account_locked_balance
func (SystemNear) AccountLockedBalance(balancePtr uint64)

// AttachedDeposit retrieves the balance locked for potential validator staking.
//
// balancePtr is a pointer to the buffer containing the data to be written.
//
//go:wasmimport env attached_deposit
func (SystemNear) AttachedDeposit(balancePtr uint64)

// PrepaidGas retrieves the amount of gas attached to the call that can be used to pay for the gas fees.
//
//go:wasmimport env prepaid_gas
func (SystemNear) PrepaidGas() uint64

// PrepaidGas retrieves the gas that was already burnt during the contract execution (cannot exceed `prepaid_gas`).
//
//go:wasmimport env used_gas
func (SystemNear) UsedGas() uint64

// RandomSeed returns the random seed from the current block. This 32 byte hash is based on the VRF value from
// the block. This value is not modified in any way each time this function is called within the
// same method/block.
//
//go:wasmimport env random_seed
func (SystemNear) RandomSeed(registerId uint64)

// Sha256 computes the SHA-256 hash of a sequence of bytes.
//
// valueLen is the length of the input data to be hashed.
//
// valuePtr is a pointer to the input data.
//
// registerId is the ID of the register where the hash result will be written.
//
// For the standard implementation, it is set to `const AtomicOpRegister uint64 = math.MaxUint64 - 2`.
//
//go:wasmimport env sha256
func (SystemNear) Sha256(valueLen, valuePtr, registerId uint64)

// Keccak256 computes the Keccak-256 hash of a sequence of bytes.
//
// valueLen is the length of the input data to be hashed.
//
// valuePtr is a pointer to the input data.
//
// registerId is the ID of the register where the hash result will be written.
//
// For the standard implementation, it is set to `const AtomicOpRegister uint64 = math.MaxUint64 - 2`.
//
//go:wasmimport env keccak256
func (SystemNear) Keccak256(valueLen, valuePtr, registerId uint64)

// Keccak512 computes the Keccak-512 hash of a sequence of bytes.
//
// valueLen is the length of the input data to be hashed.
//
// valuePtr is a pointer to the input data.
//
// registerId is the ID of the register where the hash result will be written.
//
// For the standard implementation, it is set to `const AtomicOpRegister uint64 = math.MaxUint64 - 2`.
//
//go:wasmimport env keccak512
func (SystemNear) Keccak512(valueLen, valuePtr, registerId uint64)

// Ripemd160 computes the RIPEMD-160 hash of a sequence of bytes.
//
// This returns a 20-byte hash.
//
// valueLen is the length of the input data to be hashed.
//
// valuePtr is a pointer to the input data.
//
// registerId is the ID of the register where the hash result will be written.
//
// For the standard implementation, it is set to `const AtomicOpRegister uint64 = math.MaxUint64 - 2`.
//
//go:wasmimport env ripemd160
func (SystemNear) Ripemd160(valueLen, valuePtr, registerId uint64)

// Ecrecover recovers an ECDSA signer address from a 32-byte message hash and a corresponding signature
// along with the `v` recovery byte.
// malleabilityFlag indicates whether the function should check for signature malleability,
// which is generally ideal for transactions.
//
// Returns 64 bytes representing the public key if the recovery was successful.
//
// hashLen is the length of the hash.
//
// hashPtr is a pointer to the hash data.
//
// sigLen is the length of the signature.
//
// sigPtr is a pointer to the signature data.
//
// v is the recovery byte.
//
// registerId is the ID of the register where the recovered public key will be written.
//
//go:wasmimport env ecrecover
func (SystemNear) Ecrecover(hashLen, hashPtr, sigLen, sigPtr, v, malleabilityFlag, registerId uint64) uint64

// Ed25519Verify verifies the signature of a message using the provided ED25519 public key.
//
// sigLen is the length of the signature.
//
// sigPtr is a pointer to the signature data.
//
// msgLen is the length of the message.
//
// msgPtr is a pointer to the message data.
//
// pubKeyLen is the length of the public key.
//
// pubKeyPtr is a pointer to the public key data.
//
// Returns 1 if the signature is valid, 0 otherwise.
//
//go:wasmimport env ed25519_verify
func (SystemNear) Ed25519Verify(sigLen, sigPtr, msgLen, msgPtr, pubKeyLen, pubKeyPtr uint64) uint64

// AltBn128G1Multiexp computes the multi-exponentiation operation on the `alt_bn128` curve.
// `alt_bn128` is a specific curve from the Barreto-Naehrig (BN) family, particularly
// well-suited for ZK proofs.
// See also: [EIP-196](https://eips.ethereum.org/EIPS/eip-196).
//
// valueLen is the length of the input data.
//
// valuePtr is a pointer to the input data.
//
// registerId is the ID of the register where the result will be written.
//
//go:wasmimport env alt_bn128_g1_multiexp
func (SystemNear) AltBn128G1Multiexp(valueLen, valuePtr, registerId uint64)

// AltBn128G1Sum computes the sum of multiple G1 points on the `alt_bn128` curve.
// `alt_bn128` is a specific curve from the Barreto-Naehrig (BN) family, particularly
// well-suited for ZK proofs.
// See also: [EIP-196](https://eips.ethereum.org/EIPS/eip-196).
//
// valueLen is the length of the input data.
//
// valuePtr is a pointer to the input data.
//
// registerId is the ID of the register where the result will be written.
//
//go:wasmimport env alt_bn128_g1_sum
func (SystemNear) AltBn128G1SumSystem(valueLen, valuePtr, registerId uint64)

// AltBn128PairingCheck performs a pairing check on the `alt_bn128` curve to validate
// cryptographic proofs.
// `alt_bn128` is a specific curve from the Barreto-Naehrig (BN) family, particularly
// well-suited for ZK proofs.
// See also: [EIP-197](https://eips.ethereum.org/EIPS/eip-197).
//
// valueLen is the length of the input data.
//
// valuePtr is a pointer to the input data.
//
// Returns 1 if the pairing check is valid, 0 otherwise.
//
//go:wasmimport env alt_bn128_pairing_check
func (SystemNear) AltBn128PairingCheckSystem(valueLen, valuePtr uint64) uint64

// ValidatorStake returns the current stake of a given account.
// If the account is not a validator, it returns 0.
//
// accountIdLen is the length of the account ID.
//
// accountIdPtr is a pointer to the account ID string.
//
// stakePtr is a pointer to the register where the stake amount will be written.
//
//go:wasmimport env validator_stake
func (SystemNear) ValidatorStake(accountIdLen, accountIdPtr, stakePtr uint64)

// ValidatorTotalStake returns the total stake of all validators in the current epoch.
//
// stakePtr is a pointer to the register where the total stake amount will be written.
//
//go:wasmimport env validator_total_stake
func (SystemNear) ValidatorTotalStake(stakePtr uint64)

// ValueReturn sets the blob of data as the return value of the contract.
//
// valueLen is the length of the value.
//
// valuePtr is a pointer to the value.
//
//go:wasmimport env value_return
func (SystemNear) ValueReturn(valueLen, valuePtr uint64)

// PanicUtf8 terminates the execution of the program with a UTF-8 encoded message.
//
// len is the length of the message.
//
// ptr is a pointer to the UTF-8 encoded message.
//
//go:wasmimport env panic_utf8
func (SystemNear) PanicUtf8(len, ptr uint64)

// LogUtf8 logs a message encoded in UTF-8.
//
// len is the length of the message.
//
// ptr is a pointer to the UTF-8 encoded message.
//
//go:wasmimport env log_utf8
func (SystemNear) LogUtf8(len, ptr uint64)

// LogUtf16 logs a message encoded in UTF-16.
//
// len is the length of the message.
//
// ptr is a pointer to the UTF-16 encoded message.
//
//go:wasmimport env log_utf16
func (SystemNear) LogUtf16(len, ptr uint64)

// PromiseCreate creates a promise to execute a method on a specified account with the given arguments,
// attaching the specified amount and gas.
//
// accountIdLen is the length of the target account ID.
//
// accountIdPtr is a pointer to the target account ID.
//
// functionNameLen is the length of the function name to be called.
//
// functionNamePtr is a pointer to the function name.
//
// argumentsLen is the length of the arguments for the function call.
//
// argumentsPtr is a pointer to the arguments.
//
// amountPtr is a pointer to the attached amount (must be a Unit128 value).
//
// gas is the amount of gas allocated for the execution (must be a u64 value).
//
//go:wasmimport env promise_create
func (SystemNear) PromiseCreate(accountIdLen, accountIdPtr, functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, amountPtr, gas uint64) uint64

// PromiseThen attaches a callback that executes after the promise specified by `promiseIndex` completes.
//
// promiseIndex is the index of the promise to attach the callback to.
//
// accountIdLen is the length of the target account ID.
//
// accountIdPtr is a pointer to the target account ID.
//
// functionNameLen is the length of the function name to be called.
//
// functionNamePtr is a pointer to the function name.
//
// argumentsLen is the length of the arguments for the function call.
//
// argumentsPtr is a pointer to the arguments.
//
// amountPtr is a pointer to the attached amount (must be a Unit128 value).
//
// gas is the amount of gas allocated for the execution (must be a u64 value).
//
//go:wasmimport env promise_then
func (SystemNear) PromiseThen(promiseIndex, accountIdLen, accountIdPtr, functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, amountPtr, gas uint64) uint64

// PromiseAnd creates a new promise that completes when all promises passed as arguments complete.
//
// promiseIdxPtr is a pointer to an array of promise indexes.
//
// promiseIdxCount is the number of promises in the array.
//
//go:wasmimport env promise_and
func (SystemNear) PromiseAnd(promiseIdxPtr, promiseIdxCount uint64) uint64

// PromiseBatchCreate creates a new batch promise for a specified account.
//
// accountIdLen is the length of the target account ID.
//
// accountIdPtr is a pointer to the target account ID.
//
// Returns the index of the created promise batch.
//
//go:wasmimport env promise_batch_create
func (SystemNear) PromiseBatchCreate(accountIdLen, accountIdPtr uint64) uint64

// PromiseBatchThen creates a "then" callback function that executes after the specified promise completes.
//
// promiseIndex is the index of the existing promise to attach the callback to.
//
// accountIdLen is the length of the target account ID for the callback execution.
//
// accountIdPtr is a pointer to the target account ID for the callback execution.
//
// Returns the index of the created callback promise.
//
//go:wasmimport env promise_batch_then
func (SystemNear) PromiseBatchThen(promiseIndex, accountIdLen, accountIdPtr uint64) uint64

// PromiseBatchActionCreateAccount represents the action of creating a new account as part of a promise batch.
// This action can be called after a promise batch has already been created with the represented accountId.
//
// promiseIndex is the index of the promise batch to which the account creation action will be attached.
//
//go:wasmimport env promise_batch_action_create_account
func (SystemNear) PromiseBatchActionCreateAccount(promiseIndex uint64)

// PromiseBatchActionDeployContract represents the action of deploying a contract as part of a promise batch.
// This action can be called after a promise batch has already been created with the represented accountId.
//
// promiseIndex is the index of the promise batch to which the contract deployment action will be attached.
//
// codeLen is the length of the contract code in bytes.
//
// codePtr is a pointer to the contract code to be deployed.
//
// Returns nothing, but performs the contract deployment action as part of the promise batch.
//
//go:wasmimport env promise_batch_action_deploy_contract
func (SystemNear) PromiseBatchActionDeployContract(promiseIndex, codeLen, codePtr uint64)

// PromiseBatchActionFunctionCall represents the action of invoking a function on a contract as part of a promise batch.
// This action can be called after a promise batch has already been created with the represented accountId.
//
// promiseIndex is the index of the promise batch to which the function call action will be attached.
//
// functionNameLen is the length of the function name.
//
// functionNamePtr is a pointer to the function name.
//
// argumentsLen is the length of the arguments for the function call.
//
// argumentsPtr is a pointer to the arguments to be passed.
//
// amountPtr represents the amount to attach to the call, which should be a Unit128 value.
//
// gas is the amount of gas to attach to the function call, represented as u64.
//
// Returns nothing, but performs the function call action as part of the promise batch.
//
//go:wasmimport env promise_batch_action_function_call
func (SystemNear) PromiseBatchActionFunctionCall(promiseIndex, functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, amountPtr, gas uint64)

// PromiseBatchActionFunctionCallWeight represents the action of invoking a function on a contract with a specified weight as part of a promise batch.
// This action can be called after a promise batch has already been created with the represented accountId.
//
// promiseIndex is the index of the promise batch to which the function call action will be attached.
//
// functionNameLen is the length of the function name.
//
// functionNamePtr is a pointer to the function name.
//
// argumentsLen is the length of the arguments for the function call.
//
// argumentsPtr is a pointer to the arguments to be passed.
//
// amountPtr represents the amount to attach to the call, which should be a Unit128 value.
//
// gas is the amount of gas to attach to the function call, represented as u64.
//
// weight represents the weight for the function call action.
//
// Returns nothing, but performs the function call action with weight as part of the promise batch.
//
//go:wasmimport env promise_batch_action_function_call_weight
func (SystemNear) PromiseBatchActionFunctionCallWeight(promise_index, function_name_len, function_name_ptr, arguments_len, arguments_ptr, amount_ptr, gas, weight uint64)

// PromiseBatchActionTransfer represents the action of transferring tokens as part of a promise batch.
// This action can be called after a promise batch has already been created with the represented accountId.
//
// promiseIndex is the index of the promise batch to which the transfer action will be attached.
//
// amountPtr represents the amount to transfer, which should be a Unit128 value.
//
// Returns nothing, but performs the transfer action as part of the promise batch.
//
//go:wasmimport env promise_batch_action_transfer
func (SystemNear) PromiseBatchActionTransfer(promiseIndex, amountPtr uint64)

// PromiseBatchActionStake represents the action of staking tokens as part of a promise batch.
// This action can be called after a promise batch has already been created with the represented accountId.
//
// promiseIndex is the index of the promise batch to which the staking action will be attached.
//
// amountPtr represents the amount to stake, which should be a Unit128 value.
//
// publicKeyLen is the length of the public key to associate with the staking action.
//
// publicKeyPtr is a pointer to the public key to associate with the staking action.
//
// Returns nothing, but performs the staking action as part of the promise batch.
//
//go:wasmimport env promise_batch_action_stake
func (SystemNear) PromiseBatchActionStake(promiseIndex, amountPtr, publicKeyLen, publicKeyPtr uint64)

// PromiseBatchActionAddKeyWithFullAccess represents the action of adding a key with full access as part of a promise batch.
// This action can be called after a promise batch has already been created with the represented accountId.
//
// promiseIndex is the index of the promise batch to which the key addition action will be attached.
//
// publicKeyLen is the length of the public key to associate with the full access key.
//
// publicKeyPtr is a pointer to the public key to associate with the full access key.
//
// nonce is the nonce to associate with the key addition action.
//
// Returns nothing, but performs the key addition with full access as part of the promise batch.
//
//go:wasmimport env promise_batch_action_add_key_with_full_access
func (SystemNear) PromiseBatchActionAddKeyWithFullAccess(promiseIndex, publicKeyLen, publicKeyPtr, nonce uint64)

// PromiseBatchActionAddKeyWithFunctionCall represents the action of adding a key with function call access as part of a promise batch.
// This action can be called after a promise batch has already been created with the represented accountId.
//
// promiseIndex is the index of the promise batch to which the key addition action will be attached.
//
// publicKeyLen is the length of the public key to associate with the function call access key.
//
// publicKeyPtr is a pointer to the public key to associate with the function call access key.
//
// nonce is the nonce to associate with the key addition action.
//
// allowancePtr represents the allowance for the function call access, which should be a Unit128 value.
//
// receiverIdLen is the length of the receiver account ID for the function call access.
//
// receiverIdPtr is a pointer to the receiver account ID for the function call access.
//
// functionNamesLen is the length of the function names list to associate with the key.
//
// functionNamesPtr is a pointer to the list of function names to associate with the key.
//
// Returns nothing, but performs the key addition with function call access as part of the promise batch.
//
//go:wasmimport env promise_batch_action_add_key_with_function_call
func (SystemNear) PromiseBatchActionAddKeyWithFunctionCall(promiseIndex, publicKeyLen, publicKeyPtr, nonce, allowancePtr, receiverIdLen, receiverIdPtr, functionNamesLen, functionNamesPtr uint64)

// PromiseBatchActionDeleteKey represents the action of deleting a key as part of a promise batch.
// This action can be called after a promise batch has already been created with the represented accountId.
//
// promiseIndex is the index of the promise batch to which the key deletion action will be attached.
//
// publicKeyLen is the length of the public key to delete.
//
// publicKeyPtr is a pointer to the public key to delete.
//
// Returns nothing, but performs the key deletion as part of the promise batch.
//
//go:wasmimport env promise_batch_action_delete_key
func (SystemNear) PromiseBatchActionDeleteKey(promiseIndex, publicKeyLen, publicKeyPtr uint64)

// PromiseBatchActionDeleteAccount represents the action of deleting an account as part of a promise batch.
// This action can be called after a promise batch has already been created with the represented accountId.
//
// promiseIndex is the index of the promise batch to which the account deletion action will be attached.
//
// beneficiaryIdLen is the length of the beneficiary account ID to receive any remaining balance after deletion.
//
// beneficiaryIdPtr is a pointer to the beneficiary account ID to receive any remaining balance after deletion.
//
// Returns nothing, but performs the account deletion as part of the promise batch.
//
//go:wasmimport env promise_batch_action_delete_account
func (SystemNear) PromiseBatchActionDeleteAccount(promiseIndex, beneficiaryIdLen, beneficiaryIdPtr uint64)

// PromiseYieldCreate creates a promise that will execute a method on the current account with the given arguments.
// It writes a resumption token (data id) to the specified register. The callback method will execute
// after `promise_yield_resume` is called with the data id, or after enough blocks have passed. The timeout
// length is specified by the protocol-level parameter `yield_timeout_length_in_blocks = 200`.
//
// The callback method will execute with a single promise input. The input will either be a payload
// provided by the user when calling `promise_yield_resume`, or a `PromiseError` in case of timeout.
// Resumption tokens are specific to the local account, and `promise_yield_resume` must be called from
// a method of the same contract.
//
// functionNameLen is the length of the function name to execute on the current account.
//
// functionNamePtr is a pointer to the function name to execute on the current account.
//
// argumentsLen is the length of the arguments to pass to the function.
//
// argumentsPtr is a pointer to the arguments to pass to the function.
//
// gas is the amount of gas to attach to the promise creation, specified as `u64`.
//
// gasWeight is the weight of the gas to apply to the promise, specified as `u64`.
//
// registerId is the ID of the register where the resumption token will be written.
//
// Returns the index of the created promise.
//
//go:wasmimport env promise_yield_create
func (SystemNear) PromiseYieldCreate(functionNameLen, functionNamePtr, argumentsLen, argumentsPtr, gas, gasWeight, registerId uint64) uint64

// PromiseYieldResume accepts a resumption token `data_id` created by `promise_yield_create` on the local account.
// The `data` is a payload to be passed to the callback method as a promise input. Returns false if
// no promise yield with the specified `data_id` is found. Returns true otherwise, guaranteeing
// that the callback method will be executed with a user-provided payload.
//
// If `promise_yield_resume` is called multiple times with the same `data_id`, it is possible to get
// multiple 'true' results. The payload from the first successful call is passed to the callback.
//
// dataIdLen is the length of the `data_id` (resumption token) to resume.
//
// dataIdPtr is a pointer to the `data_id` (resumption token) to resume.
//
// payloadLen is the length of the payload to pass to the callback method.
//
// payloadPtr is a pointer to the payload to pass to the callback method.
//
// Returns a `uint32`, where '1' indicates success, and '0' indicates failure (if no promise yield is found).
//
//go:wasmimport env promise_yield_resume
func (SystemNear) PromiseYieldResume(dataIdLen, dataIdPtr, payloadLen, payloadPtr uint64) uint32

// PromiseResultsCount returns the number of complete and incomplete callback results from the promises
// that triggered the current callback execution. This function can only be called if the current function
// was invoked by a callback. It helps in checking how many promise results are available for processing.
//
// Returns the count of complete and incomplete callback results.
//
//go:wasmimport env promise_results_count
func (SystemNear) PromiseResultsCount() uint64

// PromiseResult retrieves the execution result of a promise identified by `resultIdx` that caused the
// current callback. It allows access to the outcome of the promise. This function can only be called if the
// current function was invoked by a callback.
//
// resultIdx is the index of the result to retrieve.
//
// registerId is the register where the result will be stored or accessed.
//
// Returns the execution result of the specified promise.
//
//go:wasmimport env promise_result
func (SystemNear) PromiseResult(resultIdx uint64, registerId uint64) uint64

// PromiseReturn considers the execution result of the promise specified by `promiseId` as the execution
// result of the current function. This allows the callback to finalize or return the result of a promise as
// the outcome of the function.
//
// promiseId is the index of the promise whose result will be treated as the execution result of this function.
//
//go:wasmimport env promise_return
func (SystemNear) PromiseReturn(promiseId uint64)



==================================================
FILE: types/types.go
==================================================

// This package provides basic types for blockchain environment manipulation, such as Uint128, PublicKey, NearGas, and other helpful types for smart contract development.
package types

import (
	"encoding/binary"
	"encoding/hex"
	"errors"
	"math/bits"
	"strconv"
	"strings"

	"github.com/mr-tron/base58"
)

const (
	ONE_NEAR      = 1_000_000_000_000_000_000_000_000
	ONE_MILI_NEAR = 1_000_000_000_000_000_000_000
	ONE_TERA_GAS  = 1_000_000_000_000
	ONE_GIGA_GAS  = 1_000_000_000
)

const (
	ErrLoadingUint128FromBEBytes = "(UINT128_ERROR): error while loading Uint128 from BE bytes"
	ErrLoadingUint128FromLEBytes = "(UINT128_ERROR): error while loading Uint128 from LE bytes"
	ErrOverflow                  = "(UINT128_ERROR): overflow"
	ErrUnderflow                 = "(UINT128_ERROR): underflow"
	ErrOverflowInMultiplication  = "(UINT128_ERROR): overflow in multiplication"
	ErrDivisionByZero            = "(UINT128_ERROR): division by zero"
	ErrDivideByZero              = "(UINT128_ERROR): divide by zero"
	ErrIncorrectLen              = "(UINT128_ERROR): incorrect length"
	ErrUint128Overflow           = "(UINT128_ERROR): uint128 overflow"
	ErrIncorrectSymbolInString   = "(UINT128_ERROR): incorrect symbol in string"
)

// ContractInputOptions represents the options for obtaining smart contract input from the user.
//
// Input can be provided in two formats:
// 1. Raw bytes
// 2. Structured as JSON
//
// For more details, refer to the `ContractInput` method in `env.go`.
type ContractInputOptions struct {
	IsRawBytes bool
}

// Uint128 represents a 128-bit unsigned integer.
//
// This struct is used extensively in various operations, particularly with NEAR native tokens.
// Additionally, it can be utilized to create and manage custom tokens.
type Uint128 struct {
	Hi uint64
	Lo uint64
}

func LoadUint128BE(b []byte) (Uint128, error) {
	if len(b) != 16 {
		return Uint128{0, 0}, errors.New(ErrLoadingUint128FromBEBytes)
	}

	hi := binary.BigEndian.Uint64(b[:8])
	lo := binary.BigEndian.Uint64(b[8:16])

	return Uint128{Hi: hi, Lo: lo}, nil
}

func LoadUint128LE(b []byte) (Uint128, error) {
	if len(b) != 16 {
		return Uint128{0, 0}, errors.New(ErrLoadingUint128FromLEBytes)
	}

	lo := binary.LittleEndian.Uint64(b[:8])
	hi := binary.LittleEndian.Uint64(b[8:16])

	return Uint128{Hi: hi, Lo: lo}, nil
}

func (u Uint128) ToBE() []byte {
	b := make([]byte, 16)
	binary.BigEndian.PutUint64(b[:8], u.Hi)
	binary.BigEndian.PutUint64(b[8:16], u.Lo)
	return b
}

func (u Uint128) ToLE() []byte {
	b := make([]byte, 16)
	binary.LittleEndian.PutUint64(b[:8], u.Lo)
	binary.LittleEndian.PutUint64(b[8:16], u.Hi)
	return b
}

func (u Uint128) HexLE() string {
	return hex.EncodeToString(u.ToLE())
}

func (u Uint128) HexBE() string {
	return hex.EncodeToString(u.ToLE())
}

func U64ToBE(value uint64) []byte {
	b := make([]byte, 8)
	binary.BigEndian.PutUint64(b, value)
	return b
}

func U64ToLE(value uint64) []byte {
	b := make([]byte, 8)
	binary.LittleEndian.PutUint64(b, value)
	return b
}

func U64ToUint128(value uint64) Uint128 {
	return Uint128{Hi: 0, Lo: value}
}

func mul64(x, y uint64) (lo, hi uint64) {
	const mask32 = (1 << 32) - 1
	x0, x1 := x&mask32, x>>32
	y0, y1 := y&mask32, y>>32

	w0 := x0 * y0
	t := x1*y0 + w0>>32
	w1 := t & mask32
	w2 := t >> 32

	w1 += x0 * y1

	lo = x * y
	hi = x1*y1 + w2 + w1>>32
	return
}

func add64(x, y, carry uint64) (sum, carryOut uint64) {
	sum = x + y + carry
	if sum < x || (sum == x && carry != 0) {
		carryOut = 1
	}
	return
}

func sub64(x, y, borrow uint64) (diff, borrowOut uint64) {
	diff = x - y - borrow
	if x < y+borrow {
		borrowOut = 1
	} else {
		borrowOut = 0
	}
	return
}

func mul128(x, y uint64) (lo, hi uint64) {
	const mask32 = (1 << 32) - 1
	x0, x1 := x&mask32, x>>32
	y0, y1 := y&mask32, y>>32

	w0 := x0 * y0
	t := x1*y0 + w0>>32
	w1 := t & mask32
	w2 := t >> 32

	w1 += x0 * y1

	lo = x * y
	hi = x1*y1 + w2 + w1>>32
	return
}

func (u Uint128) Mul64(v uint64) Uint128 {
	lo, hi := mul64(u.Lo, v)
	return Uint128{Lo: lo, Hi: hi}
}

func (u Uint128) SafeMul64(v uint64) (Uint128, error) {
	lo, hi := mul64(u.Lo, v)
	hi += u.Hi * v
	if hi < u.Hi {
		return Uint128{0, 0}, errors.New(ErrOverflow)
	}
	return Uint128{Lo: lo, Hi: hi}, nil
}

func (u Uint128) SafeAdd64(v uint64) (Uint128, error) {
	lo, carry := add64(u.Lo, v, 0)
	hi, carry2 := add64(u.Hi, 0, carry)
	if carry2 != 0 {
		return Uint128{0, 0}, errors.New(ErrOverflow)
	}
	return Uint128{Lo: lo, Hi: hi}, nil
}

func (u Uint128) Add(v Uint128) (Uint128, error) {
	lo, carry := add64(u.Lo, v.Lo, 0)
	hi, carry2 := add64(u.Hi, v.Hi, carry)
	if carry2 != 0 {
		return Uint128{0, 0}, errors.New(ErrOverflow)
	}
	return Uint128{Lo: lo, Hi: hi}, nil
}

func (u Uint128) Sub(v Uint128) (Uint128, error) {
	lo, borrow := sub64(u.Lo, v.Lo, 0)
	hi, borrow2 := sub64(u.Hi, v.Hi, borrow)
	if borrow2 != 0 {
		return Uint128{0, 0}, errors.New(ErrUnderflow)
	}
	return Uint128{Lo: lo, Hi: hi}, nil
}

func (u Uint128) Mul(v Uint128) (Uint128, error) {
	lo, hi := mul128(u.Lo, v.Lo)
	hi1 := u.Hi * v.Lo
	hi2 := u.Lo * v.Hi

	newHi, overflow1 := add64(hi, hi1, 0)
	if overflow1 != 0 {
		return Uint128{0, 0}, errors.New(ErrOverflowInMultiplication)
	}

	newHi, overflow2 := add64(newHi, hi2, 0)
	if overflow2 != 0 {
		return Uint128{0, 0}, errors.New(ErrOverflowInMultiplication)
	}

	return Uint128{Lo: lo, Hi: newHi}, nil
}

func (u Uint128) Div(v Uint128) (Uint128, error) {
	if v.Lo == 0 && v.Hi == 0 {
		return Uint128{0, 0}, errors.New(ErrDivisionByZero)
	}

	var result Uint128
	var remainder Uint128 = u

	for remainder.GreaterOrEqual(v) {
		shift := v
		multiple := Uint128{Lo: 1, Hi: 0}

		for remainder.GreaterOrEqual(shift.ShiftLeft(1)) {
			shift = shift.ShiftLeft(1)
			multiple = multiple.ShiftLeft(1)
		}

		remainder, _ = remainder.Sub(shift)
		result, _ = result.Add(multiple)
	}

	return result, nil
}

func (u Uint128) SafeQuoRem64(v uint64) (q Uint128, r uint64, err error) {
	if v == 0 {
		return Uint128{0, 0}, 0, errors.New(ErrDivideByZero)
	}

	if u.Hi < v {
		q.Lo, r = bits.Div64(u.Hi, u.Lo, v)
	} else {
		q.Hi, r = bits.Div64(0, u.Hi, v)
		q.Lo, r = bits.Div64(r, u.Lo, v)
	}
	return
}

func (u Uint128) QuoRem64(v uint64) (q Uint128, r uint64) {
	if u.Hi < v {
		q.Lo, r = bits.Div64(u.Hi, u.Lo, v)
	} else {
		q.Hi, r = bits.Div64(0, u.Hi, v)
		q.Lo, r = bits.Div64(r, u.Lo, v)
	}
	return
}

func (u Uint128) ShiftLeft(bits uint) Uint128 {
	if bits >= 64 {
		return Uint128{Lo: 0, Hi: u.Lo << (bits - 64)}
	}
	return Uint128{Lo: u.Lo << bits, Hi: (u.Hi << bits) | (u.Lo >> (64 - bits))}
}

func (u Uint128) ShiftRight(bits uint) Uint128 {
	if bits >= 64 {
		return Uint128{Lo: u.Hi >> (bits - 64), Hi: 0}
	}
	return Uint128{Lo: (u.Lo >> bits) | (u.Hi << (64 - bits)), Hi: u.Hi >> bits}
}

func (u Uint128) GreaterOrEqual(v Uint128) bool {
	if u.Hi > v.Hi {
		return true
	}
	if u.Hi < v.Hi {
		return false
	}
	return u.Lo >= v.Lo
}

func (u Uint128) Bit(i int) uint {
	if i < 64 {
		return uint((u.Lo >> i) & 1)
	}
	return uint((u.Hi >> (i - 64)) & 1)
}

func (u Uint128) Lsh(n uint) Uint128 {
	if n == 0 {
		return u
	} else if n < 64 {
		return Uint128{
			Lo: u.Lo << n,
			Hi: (u.Hi << n) | (u.Lo >> (64 - n)),
		}
	} else {
		return Uint128{
			Lo: 0,
			Hi: u.Lo << (n - 64),
		}
	}
}

func (u Uint128) Cmp(v Uint128) int {
	if u.Hi > v.Hi || (u.Hi == v.Hi && u.Lo > v.Lo) {
		return 1
	} else if u.Hi < v.Hi || (u.Hi == v.Hi && u.Lo < v.Lo) {
		return -1
	}
	return 0
}

func (u Uint128) Mod(v Uint128) (Uint128, error) {
	if v.Lo == 0 && v.Hi == 0 {
		return Uint128{0, 0}, errors.New(ErrDivisionByZero)
	}
	_, remainder := u.QuoRem64(v.Lo)
	return U64ToUint128(remainder), nil
}

func (u Uint128) And(v Uint128) Uint128 {
	return Uint128{Lo: u.Lo & v.Lo, Hi: u.Hi & v.Hi}
}

func (u Uint128) Or(v Uint128) Uint128 {
	return Uint128{Lo: u.Lo | v.Lo, Hi: u.Hi | v.Hi}
}

func (u Uint128) Xor(v Uint128) Uint128 {
	return Uint128{Lo: u.Lo ^ v.Lo, Hi: u.Hi ^ v.Hi}
}

func isUint128Overflow(s string) bool {
	if len(s) > 39 {
		return true
	}

	if len(s) < 39 {
		return false
	}

	maxUint128Str := "340282366920938463463374607431768211455"
	for i := 0; i < 39; i++ {
		sDigit, _ := strconv.Atoi(string(s[i]))
		maxDigit, _ := strconv.Atoi(string(maxUint128Str[i]))

		if sDigit > maxDigit {
			return true
		} else if sDigit < maxDigit {
			return false
		}
	}
	return false
}

// U128FromString transforms a string into a Uint128 type.
//
// Returns an error if the string length is zero, exceeds 40 characters, or causes a Uint128 overflow.
func U128FromString(s string) (Uint128, error) {
	var res Uint128
	var err error

	if len(s) == 0 || len(s) > 40 {
		return Uint128{0, 0}, errors.New(ErrIncorrectLen)
	}

	if isUint128Overflow(s) {
		return Uint128{0, 0}, errors.New(ErrUint128Overflow)
	}

	res, err = processPart(s)

	if err != nil {
		return Uint128{0, 0}, err
	}
	return res, nil

}

func processPart(s string) (Uint128, error) {
	res := Uint128{0, 0}
	var err error

	for i := 0; i < len(s); i++ {
		ch := s[i]
		if ch < '0' || ch > '9' {
			return Uint128{0, 0}, errors.New(ErrIncorrectLen)
		}

		val := uint64(ch - '0')
		res, err = res.SafeMul64(10)

		if err != nil {
			return Uint128{0, 0}, err
		}

		res, err = res.SafeAdd64(val)

		if err != nil {
			return Uint128{0, 0}, err
		}
	}
	return res, nil
}

func (u Uint128) String() string {
	if u.Hi == 0 && u.Lo == 0 {
		return "0"
	}
	buf := []byte("0000000000000000000000000000000000000000")
	for i := len(buf); ; i -= 19 {
		q, r := u.QuoRem64(1e19)
		var n int
		for ; r != 0; r /= 10 {
			n++
			buf[i-n] += byte(r % 10)
		}
		if q.Hi == 0 && q.Lo == 0 {
			return string(buf[i-n:])
		}
		u = q
	}
}

func Uint64ToString(n uint64) string {
	if n == 0 {
		return "0"
	}

	var result []byte
	for n > 0 {
		result = append([]byte{byte('0' + n%10)}, result...)
		n /= 10
	}
	return string(result)
}

func IntToString(n int) string {
	if n == 0 {
		return "0"
	}

	negative := n < 0
	if negative {
		n = -n
	}

	var digits []byte
	for n > 0 {
		digits = append([]byte{byte('0' + n%10)}, digits...)
		n /= 10
	}

	if negative {
		digits = append([]byte{'-'}, digits...)
	}

	return string(digits)
}

func BoolToUnit(b bool) uint64 {
	if b {
		return 1
	}
	return 0
}

// NearGas represents the Gas consumed during smart contract execution.
//
// Each function call consumes a certain amount of gas. Optimizing and improving the efficiency of your code
// will reduce the amount of gas spent, resulting in faster transactions.
type NearGas struct {
	Inner uint64
}

// CurveType represents the type of cryptographic curve used.
type CurveType byte

const (
	// ED25519 represents the ed25519 curve.
	ED25519 CurveType = iota
	// SECP256K1 represents the secp256k1 curve.
	SECP256K1
)

// String returns the string representation of the CurveType.
func (c CurveType) String() string {
	switch c {
	case ED25519:
		return "ed25519"
	case SECP256K1:
		return "secp256k1"
	default:
		return "unknown"
	}
}

// DataLen returns the length of the data for the given CurveType.
func (c CurveType) DataLen() int {
	switch c {
	case ED25519:
		return 32
	case SECP256K1:
		return 64
	default:
		return 0
	}
}

// ParseCurveType parses a string to a CurveType.
func ParseCurveType(s string) (CurveType, error) {
	switch strings.ToLower(s) {
	case "ed25519":
		return ED25519, nil
	case "secp256k1":
		return SECP256K1, nil
	default:
		return 0, errors.New("unknown curve type")
	}
}

// PublicKey represents a public key with a specific curve type.
type PublicKey struct {
	Curve CurveType
	Data  []byte
}

// NewPublicKey creates a new PublicKey with the given curve type and data.
func NewPublicKey(curve CurveType, data []byte) (*PublicKey, error) {
	if len(data) != curve.DataLen() {
		return nil, errors.New("invalid data length for curve")
	}
	return &PublicKey{Curve: curve, Data: data}, nil
}

// PublicKeyFromString parses a string to create a PublicKey.
func PublicKeyFromString(s string) (*PublicKey, error) {
	parts := strings.Split(s, ":")
	if len(parts) != 2 {
		return nil, errors.New("invalid public key format")
	}

	curve, err := ParseCurveType(parts[0])
	if err != nil {
		return nil, err
	}

	data, err := base58.Decode(parts[1])
	if err != nil {
		return nil, errors.New("failed to decode Base58")
	}

	return NewPublicKey(curve, data)
}

// ToHexString returns the hexadecimal string representation of the PublicKey.
func (pk *PublicKey) ToHexString() string {
	return pk.Curve.String() + ":" + hex.EncodeToString(pk.Data)
}

// ToBase58String returns the Base58 string representation of the PublicKey.
func (pk *PublicKey) ToBase58String() string {
	return pk.Curve.String() + ":" + base58.Encode(pk.Data)
}

// Bytes returns the byte representation of the PublicKey.
func (pk *PublicKey) Bytes() []byte {
	curveByte := byte(pk.Curve)
	result := []byte{curveByte}
	result = append(result, pk.Data...)
	return result
}



==================================================
FILE: types/types_test.go
==================================================

package types

import (
	"encoding/hex"
	"fmt"
	"strconv"
	"testing"

	"github.com/mr-tron/base58"
)

func TestUint64ToString(t *testing.T) {
	testCases := []struct {
		input    uint64
		expected string
	}{
		{input: 0, expected: "0"},
		{input: 1, expected: "1"},
		{input: 10, expected: "10"},
		{input: 12345, expected: "12345"},
		{input: 9876543210, expected: "9876543210"},
		{input: 18446744073709551615, expected: "18446744073709551615"},
	}

	for _, tc := range testCases {
		t.Run(tc.expected, func(t *testing.T) {
			actual := Uint64ToString(tc.input)
			if actual != tc.expected {
				t.Errorf("Uint64ToString(%d) = %s; want %s", tc.input, actual, tc.expected)
			}
		})
	}
}

func TestBoolToUnit(t *testing.T) {
	testCases := []struct {
		input    bool
		expected uint64
	}{
		{input: true, expected: 1},
		{input: false, expected: 0},
	}

	for _, tc := range testCases {
		t.Run(strconv.FormatBool(tc.input), func(t *testing.T) {
			actual := BoolToUnit(tc.input)
			if actual != tc.expected {
				t.Errorf("BoolToUnit(%t) = %d; want %d", tc.input, actual, tc.expected)
			}
		})
	}
}

func TestLoadUint128BE(t *testing.T) {

	testCases := []struct {
		name        string
		input       []byte
		expected    Uint128
		expectedErr bool
	}{
		{
			name:        "Valid Big Endian",
			input:       []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			expected:    Uint128{Hi: 1, Lo: 2},
			expectedErr: false,
		},
		{
			name:        "Invalid Length",
			input:       []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			expected:    Uint128{0, 0},
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			actual, err := LoadUint128BE(tc.input)
			if (err != nil) != tc.expectedErr {
				t.Errorf("LoadUint128BE(%v) error = %v, wantErr %v", tc.input, err, tc.expectedErr)
				return
			}
			if actual != tc.expected {
				t.Errorf("LoadUint128BE(%v) = %v, want %v", tc.input, actual, tc.expected)
			}
		})
	}
}

func TestLoadUint128LE(t *testing.T) {
	testCases := []struct {
		name        string
		input       []byte
		expected    Uint128
		expectedErr bool
	}{
		{
			name:        "Valid Little Endian",
			input:       []byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			expected:    Uint128{Hi: 2, Lo: 1},
			expectedErr: false,
		},
		{
			name:        "Invalid Length",
			input:       []byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			expected:    Uint128{0, 0},
			expectedErr: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			actual, err := LoadUint128LE(tc.input)
			if (err != nil) != tc.expectedErr {
				t.Errorf("LoadUint128LE(%v) error = %v, wantErr %v", tc.input, err, tc.expectedErr)
				return
			}
			if actual != tc.expected {
				t.Errorf("LoadUint128LE(%v) = %v, want %v", tc.input, actual, tc.expected)
			}
		})
	}
}

func TestUint128_ToBE(t *testing.T) {
	u := Uint128{Hi: 1, Lo: 2}
	expected := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02}
	actual := u.ToBE()
	if !bytesEqual(actual, expected) {
		t.Errorf("ToLE() = %v, want %v", actual, expected)
	}
}

func TestUint128_ToLE(t *testing.T) {
	u := Uint128{Hi: 2, Lo: 1}
	expected := []byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	actual := u.ToLE()
	if !bytesEqual(actual, expected) {
		t.Errorf("ToLE() = %v, want %v", actual, expected)
	}
}

func TestU64ToBE(t *testing.T) {
	value := uint64(12345)
	expected := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x39}
	actual := U64ToBE(value)
	if !bytesEqual(actual, expected) {
		t.Errorf("U64ToBE(%d) = %v, want %v", value, actual, expected)
	}
}

func TestU64ToLE(t *testing.T) {
	value := uint64(12345)
	expected := []byte{0x39, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	actual := U64ToLE(value)
	if !bytesEqual(actual, expected) {
		t.Errorf("U64ToLE(%d) = %v, want %v", value, actual, expected)
	}
}

func TestU64ToUint128(t *testing.T) {
	value := uint64(12345)
	expected := Uint128{Hi: 0, Lo: value}
	actual := U64ToUint128(value)
	if actual != expected {
		t.Errorf("U64ToUint128(%d) = %v, want %v", value, actual, expected)
	}
}

func bytesEqual(a, b []byte) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func TestU128FromString(t *testing.T) {
	testCases := []struct {
		name        string
		input       string
		expected    Uint128
		expectedErr bool
	}{
		{
			name:        "Valid Input",
			input:       "12345678901234567890",
			expected:    Uint128{Hi: 0, Lo: 12345678901234567890},
			expectedErr: false,
		},
		{
			name:        "Zero Input",
			input:       "0",
			expected:    Uint128{Hi: 0, Lo: 0},
			expectedErr: false,
		},
		{
			name:        "Max Uint64 Input",
			input:       "18446744073709551615",
			expected:    Uint128{Hi: 0, Lo: 18446744073709551615},
			expectedErr: false,
		},
		{
			name:        "Small Hi, Large Lo",
			input:       "18446744073709551616",
			expected:    Uint128{Hi: 1, Lo: 0},
			expectedErr: false,
		},
		{
			name:        "Too Long Input",
			input:       "12345678901234567890123456789012345678901",
			expected:    Uint128{0, 0},
			expectedErr: true,
		},
		{
			name:        "Empty Input",
			input:       "",
			expected:    Uint128{0, 0},
			expectedErr: true,
		},
		{
			name:        "Invalid Character",
			input:       "123a456",
			expected:    Uint128{0, 0},
			expectedErr: true,
		},
		{
			name:        "Max Uint128 Input",
			input:       "340282366920938463463374607431768211455",
			expected:    Uint128{Hi: 0xFFFFFFFFFFFFFFFF, Lo: 0xFFFFFFFFFFFFFFFF},
			expectedErr: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			actual, err := U128FromString(tc.input)
			if (err != nil) != tc.expectedErr {
				t.Errorf("U128FromString(%q) error = %v, wantErr %v", tc.input, err, tc.expectedErr)
				return
			}
			if actual != tc.expected {
				t.Errorf("U128FromString(%q) = %v, want %v", tc.input, actual, tc.expected)
			}
		})
	}
}

func TestUint128_String(t *testing.T) {
	testCases := []struct {
		name     string
		input    Uint128
		expected string
	}{
		{
			name:     "Zero",
			input:    Uint128{Hi: 0, Lo: 0},
			expected: "0",
		},
		{
			name:     "Small Lo",
			input:    Uint128{Hi: 0, Lo: 12345},
			expected: "12345",
		},
		{
			name:     "Max Uint64",
			input:    Uint128{Hi: 0, Lo: 18446744073709551615},
			expected: "18446744073709551615",
		},
		{
			name:     "Small Hi, large Lo",
			input:    Uint128{Hi: 1, Lo: 0},
			expected: "18446744073709551616",
		},
		{
			name:     "Large Number",
			input:    Uint128{Hi: 0xFFFFFFFFFFFFFFFF, Lo: 0xFFFFFFFFFFFFFFFF},
			expected: "340282366920938463463374607431768211455",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			actual := tc.input.String()
			if actual != tc.expected {
				t.Errorf("String() for %v = %q, want %q", tc.input, actual, tc.expected)
			}
		})
	}
}

// Uint128 Math tests

func TestMul64(t *testing.T) {
	testCases := []struct {
		x  uint64
		y  uint64
		lo uint64
		hi uint64
	}{
		{x: 2, y: 3, lo: 6, hi: 0},
		{x: 18446744073709551615, y: 2, lo: 18446744073709551614, hi: 1},
		{x: 4294967295, y: 4294967295, lo: 18446744065119617025, hi: 0},
		{x: 1, y: 0, lo: 0, hi: 0},
		{x: 0, y: 1, lo: 0, hi: 0},
		{x: 18446744073709551615, y: 18446744073709551615, lo: 1, hi: 18446744073709551614},
		{x: 123456789, y: 987654321, lo: 121932631112635269, hi: 0},
		{x: 9223372036854775808, y: 2, lo: 0, hi: 1},
	}

	for _, tc := range testCases {
		t.Run(strconv.FormatUint(tc.x, 10)+"*"+strconv.FormatUint(tc.y, 10), func(t *testing.T) {
			lo, hi := mul64(tc.x, tc.y)
			if lo != tc.lo || hi != tc.hi {
				t.Errorf("mul64(%d, %d) = (%d, %d), want (%d, %d)", tc.x, tc.y, lo, hi, tc.lo, tc.hi)
			}
		})
	}
}

func TestAdd64(t *testing.T) {
	testCases := []struct {
		x        uint64
		y        uint64
		carryIn  uint64
		sum      uint64
		carryOut uint64
	}{
		{x: 1, y: 2, carryIn: 0, sum: 3, carryOut: 0},
		{x: 18446744073709551615, y: 1, carryIn: 0, sum: 0, carryOut: 1},
		{x: 18446744073709551615, y: 0, carryIn: 1, sum: 0, carryOut: 1},
		{x: 0, y: 0, carryIn: 0, sum: 0, carryOut: 0},
		{x: 0, y: 1, carryIn: 0, sum: 1, carryOut: 0},
		{x: 9223372036854775807, y: 1, carryIn: 1, sum: 9223372036854775809, carryOut: 0},
		{x: 123456789, y: 987654321, carryIn: 1, sum: 1111111111, carryOut: 0},
		{x: 0xFFFFFFFFFFFFFFFF, y: 0xFFFFFFFFFFFFFFFF, carryIn: 1, sum: 0xFFFFFFFFFFFFFFFF, carryOut: 1},
		{x: 0x8000000000000000, y: 0x8000000000000000, carryIn: 0, sum: 0, carryOut: 1},
	}

	for _, tc := range testCases {
		t.Run(strconv.FormatUint(tc.x, 10)+"+"+strconv.FormatUint(tc.y, 10)+"+"+strconv.FormatUint(tc.carryIn, 10), func(t *testing.T) {
			sum, carryOut := add64(tc.x, tc.y, tc.carryIn)
			if sum != tc.sum || carryOut != tc.carryOut {
				t.Errorf("add64(%d, %d, %d) = (%d, %d), want (%d, %d)", tc.x, tc.y, tc.carryIn, sum, carryOut, tc.sum, tc.carryOut)
			}
		})
	}
}

func TestSub64(t *testing.T) {
	testCases := []struct {
		x         uint64
		y         uint64
		borrowIn  uint64
		diff      uint64
		borrowOut uint64
	}{
		{x: 3, y: 2, borrowIn: 0, diff: 1, borrowOut: 0},
		{x: 0, y: 1, borrowIn: 0, diff: 18446744073709551615, borrowOut: 1},
		{x: 0, y: 0, borrowIn: 1, diff: 18446744073709551615, borrowOut: 1},
		{x: 1, y: 0, borrowIn: 0, diff: 1, borrowOut: 0},
		{x: 0, y: 0, borrowIn: 0, diff: 0, borrowOut: 0},
		{x: 18446744073709551615, y: 1, borrowIn: 0, diff: 18446744073709551614, borrowOut: 0},
		{x: 18446744073709551615, y: 18446744073709551615, borrowIn: 0, diff: 0, borrowOut: 0},
		{x: 18446744073709551615, y: 18446744073709551614, borrowIn: 0, diff: 1, borrowOut: 0},
		{x: 123456789, y: 987654321, borrowIn: 1, diff: 18446744072845354083, borrowOut: 1},
	}

	for _, tc := range testCases {
		t.Run(strconv.FormatUint(tc.x, 10)+"-"+strconv.FormatUint(tc.y, 10)+"-"+strconv.FormatUint(tc.borrowIn, 10), func(t *testing.T) {
			diff, borrowOut := sub64(tc.x, tc.y, tc.borrowIn)
			if diff != tc.diff || borrowOut != tc.borrowOut {
				t.Errorf("sub64(%d, %d, %d) = (%d, %d), want (%d, %d)", tc.x, tc.y, tc.borrowIn, diff, borrowOut, tc.diff, tc.borrowOut)
			}
		})
	}
}

func TestUint128_SafeAdd64(t *testing.T) {
	testCases := []struct {
		uStr        string
		v           uint64
		expectedStr string
		expectedErr bool
	}{
		{uStr: "100", v: 3, expectedStr: "103", expectedErr: false},
		{uStr: "18446744073709551615", v: 1, expectedStr: "18446744073709551616", expectedErr: false},
		{uStr: "9223372036854775808", v: 9223372036854775808, expectedStr: "18446744073709551616", expectedErr: false},
		{uStr: "0", v: 0, expectedStr: "0", expectedErr: false},
		//Result will be one because  "123456789012345678901234567890123456789000" will be parsed as 0 because its uStr > Uint128.Max
		{uStr: "123456789012345678901234567890123456789000", v: 1, expectedStr: "1", expectedErr: false},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s+%d", tc.uStr, tc.v), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			expected, _ := U128FromString(tc.expectedStr)
			actual, err := u.SafeAdd64(tc.v)

			if (err != nil) != tc.expectedErr {
				t.Errorf("SafeAdd64(%s, %d) error = %v, wantErr %v", tc.uStr, tc.v, err, tc.expectedErr)
				return
			}
			if actual != expected {
				t.Errorf("SafeAdd64(%s, %d) = %s, want %s", tc.uStr, tc.v, actual.String(), expected.String())
			}
		})
	}
}

func TestUint128_Add(t *testing.T) {
	testCases := []struct {
		uStr        string
		vStr        string
		expectedStr string
		expectedErr bool
	}{
		{uStr: "100", vStr: "3", expectedStr: "103", expectedErr: false},
		{uStr: "18446744073709551615", vStr: "1", expectedStr: "18446744073709551616", expectedErr: false},
		{uStr: "9223372036854775808", vStr: "9223372036854775808", expectedStr: "18446744073709551616", expectedErr: false},
		{uStr: "0", vStr: "0", expectedStr: "0", expectedErr: false},
		// if input of some number (v or u) will be < than Uint128.Max than it wil return 0
		{uStr: "123456789012345678901234567890123456789000", vStr: "987654321098765432109876543210987654321000", expectedStr: "0", expectedErr: false},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s+%s", tc.uStr, tc.vStr), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			v, _ := U128FromString(tc.vStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual, err := u.Add(v)

			if (err != nil) != tc.expectedErr {
				t.Errorf("Add(%s, %s) error = %v, wantErr %v", tc.uStr, tc.vStr, err, tc.expectedErr)
				return
			}
			if actual != expected {
				t.Errorf("Add(%s, %s) = %v, want %v", u.String(), v.String(), actual.String(), expected.String())
			}
		})
	}
}

func TestUint128_Sub(t *testing.T) {
	testCases := []struct {
		uStr        string
		vStr        string
		expectedStr string
		expectedErr bool
	}{
		{uStr: "105", vStr: "3", expectedStr: "102", expectedErr: false},
		{uStr: "18446744073709551616", vStr: "1", expectedStr: "18446744073709551615", expectedErr: false},
		{uStr: "18446744073709551616", vStr: "9223372036854775808", expectedStr: "9223372036854775808", expectedErr: false},
		{uStr: "1", vStr: "2", expectedStr: "0", expectedErr: true},
		{uStr: "0", vStr: "0", expectedStr: "0", expectedErr: false},
		{uStr: "1000", vStr: "1", expectedStr: "999", expectedErr: false},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s-%s", tc.uStr, tc.vStr), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			v, _ := U128FromString(tc.vStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual, err := u.Sub(v)

			if (err != nil) != tc.expectedErr {
				t.Errorf("Sub(%s, %s) error = %v, wantErr %v", tc.uStr, tc.vStr, err, tc.expectedErr)
				return
			}
			if actual != expected {
				t.Errorf("Sub(%s, %s) = %v, want %v", tc.uStr, tc.vStr, actual, expected)
			}
		})
	}
}

func TestUint128_Mul(t *testing.T) {
	testCases := []struct {
		uStr        string
		vStr        string
		expectedStr string
		expectedErr bool
	}{
		{uStr: "100", vStr: "3", expectedStr: "300", expectedErr: false},
		{uStr: "33", vStr: "3", expectedStr: "99", expectedErr: false},
		{uStr: "18446744073709551615", vStr: "2", expectedStr: "36893488147419103230", expectedErr: false},
		{uStr: "9223372036854775808", vStr: "2", expectedStr: "18446744073709551616", expectedErr: false},
		{uStr: "123456789", vStr: "987654321", expectedStr: "121932631112635269", expectedErr: false},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s * %s", tc.uStr, tc.vStr), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			v, _ := U128FromString(tc.vStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual, err := u.Mul(v)
			if (err != nil) != tc.expectedErr {
				t.Errorf("Mul(%s, %s) error = %v, wantErr %v", tc.uStr, tc.vStr, err, tc.expectedErr)
				return
			}
			if actual != expected {
				t.Errorf("Mul(%s, %s) = %v, want %v", tc.uStr, tc.vStr, actual, expected)
			}
		})
	}
}

func TestUint128_Div(t *testing.T) {
	testCases := []struct {
		uStr        string
		vStr        string
		expectedStr string
		expectedErr bool
	}{
		{uStr: "6", vStr: "2", expectedStr: "3", expectedErr: false},
		{uStr: "18446744073709551616", vStr: "2", expectedStr: "9223372036854775808", expectedErr: false},
		{uStr: "1", vStr: "1", expectedStr: "1", expectedErr: false},
		{uStr: "18446744073709551616", vStr: "18446744073709551616", expectedStr: "1", expectedErr: false},
		{uStr: "1", vStr: "0", expectedStr: "", expectedErr: true},
		{uStr: "18446744073709551617", vStr: "18446744073709551617", expectedStr: "1", expectedErr: false},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s / %s", tc.uStr, tc.vStr), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			v, _ := U128FromString(tc.vStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual, err := u.Div(v)
			if (err != nil) != tc.expectedErr {
				t.Errorf("Div(%s, %s) error = %v, wantErr %v", tc.uStr, tc.vStr, err, tc.expectedErr)
				return
			}
			if actual != expected {
				t.Errorf("Div(%s, %s) = %v, want %v", tc.uStr, tc.vStr, actual, expected)
			}
		})
	}
}

func TestUint128_SafeQuoRem64(t *testing.T) {
	testCases := []struct {
		uStr         string
		v            uint64
		expectedQStr string
		expectedR    uint64
		expectedErr  bool
	}{
		{uStr: "6", v: 2, expectedQStr: "3", expectedR: 0, expectedErr: false},
		{uStr: "18446744073709551616", v: 2, expectedQStr: "9223372036854775808", expectedR: 0, expectedErr: false},
		{uStr: "1", v: 1, expectedQStr: "1", expectedR: 0, expectedErr: false},
		{uStr: "18446744073709551617", v: 1, expectedQStr: "18446744073709551617", expectedR: 0, expectedErr: false},
		{uStr: "1", v: 0, expectedQStr: "", expectedR: 0, expectedErr: true},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s / %d", tc.uStr, tc.v), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			expectedQ, _ := U128FromString(tc.expectedQStr)

			actualQ, actualR, err := u.SafeQuoRem64(tc.v)

			if tc.expectedErr {
				if err == nil {
					t.Errorf("SafeQuoRem64(%s, %d) expected error, but got nil", tc.uStr, tc.v)
				}
				return
			} else if err != nil {
				t.Errorf("SafeQuoRem64(%s, %d) returned error: %v, but did not expect one", tc.uStr, tc.v, err)
				return
			}

			if actualQ != expectedQ {
				t.Errorf("SafeQuoRem64(%s, %d) quotient = %v, want %v", tc.uStr, tc.v, actualQ, expectedQ)
			}
			if actualR != tc.expectedR {
				t.Errorf("SafeQuoRem64(%s, %d) remainder = %d, want %d", tc.uStr, tc.v, actualR, tc.expectedR)
			}
		})
	}
}

func TestUint128_QuoRem64(t *testing.T) {
	testCases := []struct {
		uStr         string
		v            uint64
		expectedQStr string
		expectedR    uint64
	}{
		{uStr: "6", v: 2, expectedQStr: "3", expectedR: 0},
		{uStr: "18446744073709551616", v: 2, expectedQStr: "9223372036854775808", expectedR: 0},
		{uStr: "1", v: 1, expectedQStr: "1", expectedR: 0},
		{uStr: "18446744073709551617", v: 1, expectedQStr: "18446744073709551617", expectedR: 0},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s / %d", tc.uStr, tc.v), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			expectedQ, _ := U128FromString(tc.expectedQStr)

			actualQ, actualR := u.QuoRem64(tc.v)

			if actualQ != expectedQ {
				t.Errorf("QuoRem64(%s, %d) quotient = %v, want %v", tc.uStr, tc.v, actualQ, expectedQ)
			}
			if actualR != tc.expectedR {
				t.Errorf("QuoRem64(%s, %d) remainder = %d, want %d", tc.uStr, tc.v, actualR, tc.expectedR)
			}
		})
	}
}

func TestUint128_ShiftLeft(t *testing.T) {
	testCases := []struct {
		uStr        string
		bits        uint
		expectedStr string
	}{
		{uStr: "1", bits: 1, expectedStr: "2"},
		{uStr: "1", bits: 64, expectedStr: "18446744073709551616"},
		{uStr: "2", bits: 1, expectedStr: "4"},
		{uStr: "3", bits: 2, expectedStr: "12"},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s<<%d", tc.uStr, tc.bits), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual := u.ShiftLeft(tc.bits)
			if actual != expected {
				t.Errorf("ShiftLeft(%s, %d) = %v, want %v", tc.uStr, tc.bits, actual.String(), expected.String())
			}
		})
	}
}

func TestUint128_ShiftRight(t *testing.T) {
	testCases := []struct {
		uStr        string
		bits        uint
		expectedStr string
	}{
		{uStr: "2", bits: 1, expectedStr: "1"},
		{uStr: "4", bits: 1, expectedStr: "2"},
		{uStr: "18446744073709551616", bits: 64, expectedStr: "1"},
		{uStr: "18446744073709551616", bits: 1, expectedStr: "9223372036854775808"},
		{uStr: "18446744073709551616", bits: 63, expectedStr: "2"},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s>>%d", tc.uStr, tc.bits), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual := u.ShiftRight(tc.bits)
			if actual != expected {
				t.Errorf("ShiftRight(%s, %d) = %v, want %v", u.String(), tc.bits, actual.String(), expected.String())
			}
		})
	}
}

func TestUint128_GreaterOrEqual(t *testing.T) {
	testCases := []struct {
		uStr     string
		vStr     string
		expected bool
	}{
		{uStr: "100", vStr: "99", expected: true},
		{uStr: "99", vStr: "100", expected: false},
		{uStr: "100", vStr: "100", expected: true},
		{uStr: "18446744073709551615", vStr: "9223372036854775808", expected: true},
		{uStr: "9223372036854775808", vStr: "18446744073709551615", expected: false},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s >= %s", tc.uStr, tc.vStr), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			v, _ := U128FromString(tc.vStr)

			actual := u.GreaterOrEqual(v)
			if actual != tc.expected {
				t.Errorf("GreaterOrEqual(%s, %s) = %v, want %v", u.String(), v.String(), actual, tc.expected)
			}
		})
	}
}

func TestUint128_Bit(t *testing.T) {
	testCases := []struct {
		uStr        string
		index       int
		expectedBit uint
	}{
		{uStr: "4", index: 2, expectedBit: 1},
		{uStr: "2", index: 1, expectedBit: 1},
		{uStr: "1", index: 0, expectedBit: 1},
		{uStr: "18446744073709551616", index: 64, expectedBit: 1},
		{uStr: "9223372036854775808", index: 63, expectedBit: 1},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s[%d]", tc.uStr, tc.index), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)

			actualBit := u.Bit(tc.index)
			if actualBit != tc.expectedBit {
				t.Errorf("Bit(%s, %d) = %v, want %v", u.String(), tc.index, actualBit, tc.expectedBit)
			}
		})
	}
}

func TestUint128_Lsh(t *testing.T) {
	testCases := []struct {
		uStr        string
		n           uint
		expectedStr string
	}{
		{uStr: "1", n: 1, expectedStr: "2"},
		{uStr: "9223372036854775808", n: 1, expectedStr: "18446744073709551616"},
		{uStr: "1", n: 64, expectedStr: "18446744073709551616"},
		{uStr: "18446744073709551615", n: 1, expectedStr: "36893488147419103230"},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s Lsh %d", tc.uStr, tc.n), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual := u.Lsh(tc.n)
			if actual != expected {
				t.Errorf("Lsh(%s, %d) = %v, want %v", u.String(), tc.n, actual.String(), expected.String())
			}
		})
	}
}

func TestUint128_Cmp(t *testing.T) {
	testCases := []struct {
		uStr     string
		vStr     string
		expected int
	}{
		{uStr: "100", vStr: "99", expected: 1},
		{uStr: "99", vStr: "100", expected: -1},
		{uStr: "100", vStr: "100", expected: 0},
		{uStr: "18446744073709551615", vStr: "9223372036854775808", expected: 1},
		{uStr: "9223372036854775808", vStr: "18446744073709551615", expected: -1},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s Cmp %s", tc.uStr, tc.vStr), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			v, _ := U128FromString(tc.vStr)

			actual := u.Cmp(v)
			if actual != tc.expected {
				t.Errorf("Cmp(%s, %s) = %v, want %v", u.String(), v.String(), actual, tc.expected)
			}
		})
	}
}

func TestUint128_Mod(t *testing.T) {
	testCases := []struct {
		uStr        string
		vStr        string
		expectedStr string
		expectedErr bool
	}{
		{uStr: "10", vStr: "3", expectedStr: "1", expectedErr: false},
		{uStr: "18446744073709551616", vStr: "2", expectedStr: "0", expectedErr: false},
		{uStr: "1", vStr: "1", expectedStr: "0", expectedErr: false},
		{uStr: "1", vStr: "0", expectedStr: "", expectedErr: true},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s %% %s", tc.uStr, tc.vStr), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			v, _ := U128FromString(tc.vStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual, err := u.Mod(v)
			if (err != nil) != tc.expectedErr {
				t.Errorf("Mod(%s, %s) error = %v, wantErr %v", u.String(), v.String(), err, tc.expectedErr)
				return
			}
			if actual != expected {
				t.Errorf("Mod(%s, %s) = %v, want %v", u.String(), v.String(), actual.String(), expected.String())
			}
		})
	}
}

func TestUint128_And(t *testing.T) {
	testCases := []struct {
		uStr        string
		vStr        string
		expectedStr string
	}{
		{uStr: "5", vStr: "3", expectedStr: "1"},
		{uStr: "18446744073709551616", vStr: "1", expectedStr: "0"},
		{uStr: "255", vStr: "15", expectedStr: "15"},
		{uStr: "9223372036854775808", vStr: "1", expectedStr: "0"},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s & %s", tc.uStr, tc.vStr), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			v, _ := U128FromString(tc.vStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual := u.And(v)
			if actual != expected {
				t.Errorf("And(%s, %s) = %v, want %v", u.String(), v.String(), actual.String(), expected.String())
			}
		})
	}
}

func TestUint128_Or(t *testing.T) {
	testCases := []struct {
		uStr        string
		vStr        string
		expectedStr string
	}{
		{uStr: "5", vStr: "3", expectedStr: "7"},
		{uStr: "18446744073709551616", vStr: "1", expectedStr: "18446744073709551617"},
		{uStr: "255", vStr: "15", expectedStr: "255"},
		{uStr: "9223372036854775808", vStr: "1", expectedStr: "9223372036854775809"},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s | %s", tc.uStr, tc.vStr), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			v, _ := U128FromString(tc.vStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual := u.Or(v)
			if actual != expected {
				t.Errorf("Or(%s, %s) = %v, want %v", u.String(), v.String(), actual.String(), expected.String())
			}
		})
	}
}

func TestUint128_Xor(t *testing.T) {
	testCases := []struct {
		uStr        string
		vStr        string
		expectedStr string
	}{
		{uStr: "5", vStr: "3", expectedStr: "6"},
		{uStr: "18446744073709551616", vStr: "1", expectedStr: "18446744073709551617"},
		{uStr: "255", vStr: "15", expectedStr: "240"},
		{uStr: "9223372036854775808", vStr: "1", expectedStr: "9223372036854775809"},
	}

	for _, tc := range testCases {
		t.Run(fmt.Sprintf("%s ^ %s", tc.uStr, tc.vStr), func(t *testing.T) {
			u, _ := U128FromString(tc.uStr)
			v, _ := U128FromString(tc.vStr)
			expected, _ := U128FromString(tc.expectedStr)

			actual := u.Xor(v)
			if actual != expected {
				t.Errorf("Xor(%s, %s) = %v, want %v", u.String(), v.String(), actual.String(), expected.String())
			}
		})
	}
}

// Uint128 Math tests

//PublicKey type tests

func TestParseCurveType(t *testing.T) {
	testCases := []struct {
		input    string
		expected CurveType
		err      bool
	}{
		{input: "ed25519", expected: ED25519, err: false},
		{input: "secp256k1", expected: SECP256K1, err: false},
		{input: "unknown", expected: 0, err: true},
	}

	for _, tc := range testCases {
		t.Run(tc.input, func(t *testing.T) {
			actual, err := ParseCurveType(tc.input)
			if (err != nil) != tc.err {
				t.Errorf("ParseCurveType(%s) error = %v, wantErr %v", tc.input, err, tc.err)
				return
			}
			if actual != tc.expected {
				t.Errorf("ParseCurveType(%s) = %v; want %v", tc.input, actual, tc.expected)
			}
		})
	}
}

func TestNewPublicKey(t *testing.T) {
	testCases := []struct {
		curve    CurveType
		data     []byte
		expected *PublicKey
		err      bool
	}{
		{curve: ED25519, data: make([]byte, 32), expected: &PublicKey{Curve: ED25519, Data: make([]byte, 32)}, err: false},
		{curve: SECP256K1, data: make([]byte, 64), expected: &PublicKey{Curve: SECP256K1, Data: make([]byte, 64)}, err: false},
		{curve: ED25519, data: make([]byte, 31), expected: nil, err: true},
	}

	for _, tc := range testCases {
		t.Run(tc.curve.String(), func(t *testing.T) {
			actual, err := NewPublicKey(tc.curve, tc.data)
			if (err != nil) != tc.err {
				t.Errorf("NewPublicKey(%v, %v) error = %v, wantErr %v", tc.curve, tc.data, err, tc.err)
				return
			}
			if actual != nil && !comparePublicKey(actual, tc.expected) {
				t.Errorf("NewPublicKey(%v, %v) = %v; want %v", tc.curve, tc.data, actual, tc.expected)
			}
		})
	}
}

func TestPublicKeyFromString(t *testing.T) {
	testCases := []struct {
		input    string
		expected *PublicKey
		err      bool
	}{
		{input: "ed25519:ExeqWPvjcUjLX3NfTk3JzisaXLjsCqJNZFCj7ub92RQW", expected: &PublicKey{Curve: ED25519, Data: decodeBase58("ExeqWPvjcUjLX3NfTk3JzisaXLjsCqJNZFCj7ub92RQW")}, err: false},
		{input: "secp256k1:qMoRgcoXai4mBPsdbHi1wfyxF9TdbPCF4qSDQTRP3TfescSRoUdSx6nmeQoN3aiwGzwMyGXAb1gUjBTv5AY8DXj", expected: &PublicKey{Curve: SECP256K1, Data: decodeBase58("qMoRgcoXai4mBPsdbHi1wfyxF9TdbPCF4qSDQTRP3TfescSRoUdSx6nmeQoN3aiwGzwMyGXAb1gUjBTv5AY8DXj")}, err: false},
		{input: "unknown:1234", expected: nil, err: true},
	}

	for _, tc := range testCases {
		t.Run(tc.input, func(t *testing.T) {
			actual, err := PublicKeyFromString(tc.input)
			if (err != nil) != tc.err {
				t.Errorf("PublicKeyFromString(%s) error = %v, wantErr %v", tc.input, err, tc.err)
				return
			}
			if actual != nil && !comparePublicKey(actual, tc.expected) {
				t.Errorf("PublicKeyFromString(%s) = %v; want %v", tc.input, actual, tc.expected)
			}
		})
	}
}

func TestPublicKeyToHexString(t *testing.T) {
	testCases := []struct {
		input    *PublicKey
		expected string
	}{
		{input: &PublicKey{Curve: ED25519, Data: decodeBase58("ExeqWPvjcUjLX3NfTk3JzisaXLjsCqJNZFCj7ub92RQW")}, expected: "ed25519:" + encodeHex(decodeBase58("ExeqWPvjcUjLX3NfTk3JzisaXLjsCqJNZFCj7ub92RQW"))},
	}

	for _, tc := range testCases {
		t.Run(tc.expected, func(t *testing.T) {
			actual := tc.input.ToHexString()
			if actual != tc.expected {
				t.Errorf("ToHexString() = %s; want %s", actual, tc.expected)
			}
		})
	}
}

func TestPublicKeyToBase58String(t *testing.T) {
	testCases := []struct {
		input    *PublicKey
		expected string
	}{
		{input: &PublicKey{Curve: ED25519, Data: decodeBase58("ExeqWPvjcUjLX3NfTk3JzisaXLjsCqJNZFCj7ub92RQW")}, expected: "ed25519:ExeqWPvjcUjLX3NfTk3JzisaXLjsCqJNZFCj7ub92RQW"},
	}

	for _, tc := range testCases {
		t.Run(tc.expected, func(t *testing.T) {
			actual := tc.input.ToBase58String()
			if actual != tc.expected {
				t.Errorf("ToBase58String() = %s; want %s", actual, tc.expected)
			}
		})
	}
}

func comparePublicKey(a, b *PublicKey) bool {
	if a.Curve != b.Curve {
		return false
	}
	if !compareBytes(a.Data, b.Data) {
		return false
	}
	return true
}

func compareBytes(a, b []byte) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func decodeBase58(s string) []byte {
	decoded, _ := base58.Decode(s)
	return decoded
}

func encodeHex(data []byte) string {
	return hex.EncodeToString(data)
}

//PublicKey type tests



